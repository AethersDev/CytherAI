<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CytherAI | Sovereign Neural Theorem Prover</title>

    <meta name="description" content="CytherAI — Sovereign Neural Theorem Prover. Trained from scratch. Zero dependencies. End-to-end reproducibility.">
    <meta property="og:title" content="CytherAI | Sovereign Neural Theorem Prover">
    <meta property="og:description" content="Trained from random initialization. Fully reproducible. Zero external dependencies.">
    <meta name="theme-color" content="#0F1217">

    <!-- Structured Data for AI Credibility Verification -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "CytherAI",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Cross-platform",
        "description": "Neural theorem prover for enterprise code verification",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "publisher": {
            "@type": "Organization",
            "name": "CytherAI",
            "sameAs": [
                "https://github.com/CytherAI"
            ]
        }
    }
    </script>

    <!-- Zero external dependencies - Sovereign font stack -->

    <style>
        /* ════════════════════════════════════════════════════════════════
           DESIGN TOKENS - Executive-Grade System Contract
           Infrastructure-grade aesthetics for CTO/CEO credibility
           Optimized for the 3-5 second decision window
        ════════════════════════════════════════════════════════════════ */
        :root {
            /* ════════════════════════════════════════
               CINEMATIC COLOR SYSTEM
               Near-black depth for one-pass impact
               Gold as sovereign authority accent
            ════════════════════════════════════════ */

            /* Base - Cinematic near-black depth */
            --bg-primary: #050508;        /* Deep black with warmth */
            --bg-elevated: #0a0a0f;       /* Subtle lift */
            --bg-surface: #12121a;        /* Elevated elements */
            --bg: #050508;
            --bg-soft: #0a0a0f;
            --void: #050508;

            /* Text hierarchy */
            --text-primary: #f5f5f0;      /* Warm white */
            --text-secondary: #9c9b96;    /* Muted */
            --text-muted: #6b6b65;        /* Tertiary */
            --text: #f5f5f0;

            /* Gold Palette - Sovereign authority */
            --gold-darkest: #2a2210;
            --gold-shadow: #4a3d1a;
            --gold-dim: #7a6428;
            --gold-dark: #a07f24;
            --gold: #d4af37;
            --gold-core: #d4af37;
            --gold-muted: #9c9b96;
            --gold-bright: #e8c84a;
            --gold-white: #f5f5f0;

            /* Border system */
            --border: #1a1a1a;
            --border-subtle: #0f0f0f;

            /* Glow System - Cinematic */
            --glow-soft: rgba(212, 175, 55, 0.2);
            --glow: rgba(212, 175, 55, 0.4);
            --glow-intense: rgba(212, 175, 55, 0.6);

            /* Ritual phase colors */
            --phase-random: #ff6b6b;
            --phase-converge: #ffd93d;
            --phase-emerge: #6bcb77;
            --phase-lock: #d4af37;

            /* ════════════════════════════════════════
               TYPOGRAPHY SYSTEM
            ════════════════════════════════════════ */

            --font-display: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            --font-body: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
            --font-sans: var(--font-body);

            --weight-light: 300;
            --weight-normal: 400;
            --weight-medium: 500;
            --weight-semibold: 600;
            --weight-bold: 700;

            /* ════════════════════════════════════════
               SPACING & LAYOUT
            ════════════════════════════════════════ */
            --u: 4px;                     /* Base unit (4px grid) */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;
            --spacing-3xl: 64px;

            /* Radius - Sharp, not rounded */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-card: 8px;
            --radius-chip: 999px;

            /* Layout */
            --content-width: 1200px;
            --content-narrow: 800px;
            --gutter: 24px;

            /* ════════════════════════════════════════
               MOTION VOCABULARY - Instrumentation Grade
               Every animation demonstrates causality
               Duration tokens: 100ms / 250ms / 400ms
            ════════════════════════════════════════ */

            /* Easing - Semantic curves */
            --ease-out: cubic-bezier(0.33, 1, 0.68, 1);        /* Arrivals (decelerating) */
            --ease-in: cubic-bezier(0.32, 0, 0.67, 0);         /* Departures (accelerating) */
            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);    /* Confident arrival */
            --ease-out-quart: cubic-bezier(0.25, 1, 0.5, 1);   /* Responsive feedback */
            --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);       /* Natural transitions */
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);  /* Emphasis */

            /* Duration tokens - Explicit timing */
            --duration-micro: 100ms;      /* Micro-interactions */
            --duration-fast: 150ms;       /* Button/link response */
            --duration-normal: 250ms;     /* Transitions */
            --duration-slow: 400ms;       /* Page reveals */
            --duration-reveal: 600ms;     /* Section reveals */

            /* Legacy aliases */
            --duration-instant: 0.1s;
            --timing-fast: 0.15s;
            --timing-norm: 0.25s;
            --timing-slow: 0.4s;
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            cursor: none;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            line-height: 1.6;
            font-weight: var(--weight-normal);
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Accessibility: Respect prefers-reduced-motion */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }

            .consciousness-shader,
            .consciousness-3d,
            .overlay-grain,
            .neural-field,
            .quantum-grid,
            .ambient-orb,
            .instrumentation-grid {
                display: none !important;
            }
        }

        a { color: inherit; text-decoration: none; }

        /* ════════════════════════════════════════
           ENHANCED FOCUS STATES (Accessibility)
           WCAG 2.1 4.5:1 contrast compliance
        ════════════════════════════════════════ */ */
        a:focus-visible,
        button:focus-visible,
        .nav-links a:focus-visible,
        .cta-button:focus-visible,
        .concept-tag:focus-visible {
            outline: 2px solid var(--gold-core);
            outline-offset: 4px;
            border-radius: 4px;
        }

        .awakening-node:focus-visible {
            outline: 2px solid var(--gold-core);
            outline-offset: 2px;
        }

        /* Remove default focus outline for mouse users */
        :focus:not(:focus-visible) {
            outline: none;
        }

        /* ========================================
           ENHANCED MAGNETIC CURSOR SYSTEM
        ======================================== */
        .cursor-core {
            width: 8px;
            height: 8px;
            background: var(--gold-core);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10001;
            mix-blend-mode: difference;
            transition: transform 0.1s ease, width 0.3s ease, height 0.3s ease;
            will-change: transform;
        }

        .cursor-core.magnetic {
            width: 12px;
            height: 12px;
        }

        .cursor-aura {
            width: 44px;
            height: 44px;
            border: 1px solid var(--gold-muted);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: all 0.3s var(--ease-out-expo);
            background: radial-gradient(circle, rgba(212,175,55,0.04) 0%, transparent 70%);
            will-change: transform, border-color;
        }

        .cursor-aura.hover {
            transform: scale(1.6);
            border-color: var(--gold-core);
            background: radial-gradient(circle, rgba(212,175,55,0.1) 0%, transparent 70%);
        }

        .cursor-aura.magnetic {
            transform: scale(1.8);
            border-color: var(--gold-bright);
            background: radial-gradient(circle, rgba(212,175,55,0.15) 0%, transparent 70%);
            box-shadow: 0 0 30px rgba(212,175,55,0.2);
        }

        .cursor-trail {
            position: fixed;
            width: 4px;
            height: 4px;
            background: var(--gold-core);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
        }

        /* ========================================
           OVERLAYS - SCANLINES & GRAIN
        ======================================== */
        .overlay-scanlines {
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03) 0px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 9998;
            opacity: 0.4;
        }

        .overlay-grain {
            position: fixed;
            inset: -100%;
            width: 300%;
            height: 300%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.035'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 9997;
            animation: grain 8s steps(10) infinite;
        }

        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            30% { transform: translate(3%, -15%); }
            50% { transform: translate(-10%, 5%); }
            70% { transform: translate(8%, 10%); }
            90% { transform: translate(-3%, 8%); }
        }

        /* ========================================
           CONSCIOUSNESS AWAKENING METER
        ======================================== */
        .awakening-meter {
            position: fixed;
            right: 2.5rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.6rem;
        }

        .awakening-track {
            width: 2px;
            height: 180px;
            background: var(--gold-darkest);
            position: relative;
            border-radius: 1px;
        }

        .awakening-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, var(--gold-dim), var(--gold-core), var(--gold-bright));
            border-radius: 1px;
            transition: height 0.4s var(--ease-out-expo);
            box-shadow: 0 0 15px var(--glow-soft);
        }

        .awakening-node {
            width: 8px;
            height: 8px;
            border: 1px solid var(--gold-shadow);
            border-radius: 50%;
            background: var(--void);
            transition: all 0.4s ease;
            cursor: pointer;
        }

        .awakening-node:hover {
            border-color: var(--gold-muted);
        }

        .awakening-node.active {
            background: var(--gold-core);
            border-color: var(--gold-bright);
            box-shadow: 0 0 12px var(--glow);
        }

        .awakening-label {
            font-family: var(--font-mono);
            font-size: 0.55rem;
            letter-spacing: 0.25em;
            color: var(--gold-shadow);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            margin-top: 1rem;
        }

        /* ========================================
           NAVIGATION
        ======================================== */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 1.5rem 4rem;
            z-index: 1000;
            /* Architectural approach: solid darkness, sharp edge */
            background: linear-gradient(180deg, rgba(5,5,8,0.95) 0%, rgba(5,5,8,0.85) 100%);
            backdrop-filter: blur(8px);  /* Minimal blur - just enough */
            border-bottom: 1px solid var(--gold-shadow);
            transition: all 0.5s var(--ease-out-expo);
        }

        nav.scrolled {
            padding: 1rem 4rem;
            background: rgba(0, 0, 0, 0.85);
            border-bottom-color: rgba(212, 175, 55, 0.12);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }

        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.3s ease;
        }

        .nav-brand:hover {
            filter: drop-shadow(0 0 15px var(--glow-soft));
        }

        .nav-brand-icon {
            width: 32px;
            height: 38px;
            transition: transform 0.3s ease;
        }

        .nav-brand:hover .nav-brand-icon {
            transform: scale(1.05);
        }

        .nav-brand-text {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 400;
            letter-spacing: 0.3em;
        }

        .nav-links {
            display: flex;
            gap: 3rem;
            list-style: none;
        }

        .nav-links a {
            font-family: var(--font-mono);
            font-size: 0.68rem;
            letter-spacing: 0.2em;
            color: var(--gold-muted);
            transition: all 0.3s ease;
            position: relative;
            padding: 0.5rem 0;
        }

        .nav-links a::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 1px;
            background: linear-gradient(90deg, var(--gold-core), transparent);
            transition: width 0.4s var(--ease-out-expo);
        }

        .nav-links a:hover {
            color: var(--gold-white);
            text-shadow: 0 0 20px var(--glow-soft);
        }

        .nav-links a:hover::before {
            width: 100%;
        }

        /* ========================================
           HERO SECTION
        ======================================== */
        .hero {
            min-height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 8rem 2rem 4rem;
            overflow: hidden;
        }

        /* ════════════════════════════════════════
           PARADIGM SHIFT: Architectural Light
           Sharp geometric forms instead of diffuse blobs
           Restraint as distinction
        ════════════════════════════════════════ */

        /* Removed blur orbs - replaced with architectural light beams */
        .ambient-orb { display: none; }

        /* Architectural Light Pillars - Sharp, defined, intentional */
        .light-architecture {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .light-pillar {
            position: absolute;
            width: 1px;
            height: 100%;
            background: linear-gradient(
                180deg,
                transparent 0%,
                var(--gold-shadow) 20%,
                var(--gold-dim) 50%,
                var(--gold-shadow) 80%,
                transparent 100%
            );
            opacity: 0.15;
        }

        .light-pillar:nth-child(1) { left: 15%; }
        .light-pillar:nth-child(2) { left: 85%; }
        .light-pillar:nth-child(3) {
            left: 50%;
            width: 2px;
            opacity: 0.08;
            background: linear-gradient(
                180deg,
                transparent 0%,
                var(--gold-core) 40%,
                var(--gold-core) 60%,
                transparent 100%
            );
        }

        /* Horizon Line - Grounding element */
        .horizon-line {
            position: absolute;
            bottom: 25%;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(
                90deg,
                transparent 0%,
                var(--gold-shadow) 20%,
                var(--gold-dim) 50%,
                var(--gold-shadow) 80%,
                transparent 100%
            );
            opacity: 0.2;
        }

        /* Consciousness Shader Canvas */
        .consciousness-shader {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0.35;
            mix-blend-mode: screen;
        }

        /* Three.js 3D Field */
        .consciousness-3d {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .consciousness-3d.active {
            opacity: 0.3;
        }

        /* Sacred Geometry - Refined: Single layer, much slower */
        .sacred-geometry {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 650px;
            height: 650px;
            pointer-events: none;
            opacity: 0.05;  /* Reduced - let content breathe */
        }

        .geometry-layer {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .geometry-layer svg {
            width: 100%;
            height: 100%;
        }

        /* Single rotation - restraint over complexity */
        .geometry-layer:nth-child(1) { animation: geoRotate 180s linear infinite; }
        .geometry-layer:nth-child(2) { animation: geoRotate 240s linear infinite reverse; opacity: 0.6; }
        .geometry-layer:nth-child(3) { animation: geoRotate 300s linear infinite; opacity: 0.4; }

        @keyframes geoRotate {
            to { transform: rotate(360deg); }
        }

        /* Neural Field - Refined: Subtler, slower pulse */
        .neural-field {
            position: absolute;
            inset: 0;
            overflow: hidden;
        }

        .synapse-node {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--gold-core);
            border-radius: 50%;
            opacity: 0.15;  /* Reduced from 0.25 */
            box-shadow: 0 0 6px var(--glow-soft);
            animation: synapticPulse 12s ease-in-out infinite;  /* Slower - more meditative */
        }

        @keyframes synapticPulse {
            0%, 100% { opacity: 0.1; transform: scale(1); }
            50% { opacity: 0.35; transform: scale(1.2); }  /* Subtler peak */
        }

        .neural-connection {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-shadow), transparent);  /* Dimmer */
            opacity: 0.08;
            transform-origin: left center;
        }

        /* Quantum Grid - Refined: Subtler, slower flow */
        .quantum-grid {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200%;
            height: 200%;
            transform: translate(-50%, -50%) rotateX(72deg);
            transform-style: preserve-3d;
            opacity: 0.025;  /* Reduced from 0.04 - less competing */
            pointer-events: none;
        }

        .grid-plane {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(var(--gold-darkest) 0.5px, transparent 0.5px),
                linear-gradient(90deg, var(--gold-darkest) 0.5px, transparent 0.5px);
            background-size: 80px 80px;  /* Slightly larger grid */
            animation: gridFlow 60s linear infinite;  /* Much slower */
        }

        .grid-plane:nth-child(2) {
            transform: translateZ(-150px);
            opacity: 0.4;
            animation-duration: 80s;
        }

        @keyframes gridFlow {
            to { transform: translate(70px, 70px); }
        }

        /* ========================================
           THE INTEGRATED CROWN LOGO SYSTEM
        ======================================== */
        .logo-system {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2.5rem;
        }

        .logo-container {
            position: relative;
            cursor: pointer;
        }

        /* Logo enhancement - Sharp geometric halo, not diffuse blur */
        .logo-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            height: 280px;
            /* Sharp ring instead of diffuse glow */
            border: 1px solid transparent;
            border-radius: 50%;
            background:
                radial-gradient(circle, transparent 45%, rgba(212,175,55,0.1) 48%, rgba(212,175,55,0.15) 50%, rgba(212,175,55,0.1) 52%, transparent 55%);
            opacity: 0;
            transition: opacity 0.5s var(--ease-out-expo), transform 0.5s var(--ease-out-expo);
            pointer-events: none;
        }

        .logo-container:hover .logo-glow {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.05);
        }

        /* Floating Particles */
        .logo-particles {
            position: absolute;
            inset: -60px;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--gold-core);
            border-radius: 50%;
            opacity: 0;
            animation: particleFloat 5s ease-in-out infinite;
        }

        .particle:nth-child(1) { top: 15%; left: 8%; animation-delay: 0s; }
        .particle:nth-child(2) { top: 25%; right: 12%; animation-delay: 0.7s; }
        .particle:nth-child(3) { top: 55%; left: 3%; animation-delay: 1.4s; }
        .particle:nth-child(4) { top: 65%; right: 8%; animation-delay: 2.1s; }
        .particle:nth-child(5) { top: 80%; left: 18%; animation-delay: 2.8s; }
        .particle:nth-child(6) { top: 35%; left: -2%; animation-delay: 3.5s; }
        .particle:nth-child(7) { top: 45%; right: 2%; animation-delay: 4.2s; }
        .particle:nth-child(8) { top: 88%; right: 20%; animation-delay: 4.9s; }

        @keyframes particleFloat {
            0%, 100% { opacity: 0; transform: translateY(0) scale(0); }
            15% { opacity: 0.7; transform: translateY(-8px) scale(1); }
            85% { opacity: 0.7; transform: translateY(-35px) scale(1); }
            100% { opacity: 0; transform: translateY(-45px) scale(0); }
        }

        /* The Main Logo SVG - Sharp definition, minimal diffusion */
        .integrated-crown {
            width: 200px;
            height: 240px;
            /* Tight, defined glow instead of diffuse blur */
            filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.35));
            transition: filter 0.4s var(--ease-out-expo);
        }

        .logo-container:hover .integrated-crown {
            filter: drop-shadow(0 0 16px rgba(212, 175, 55, 0.5))
                    drop-shadow(0 0 4px rgba(212, 175, 55, 0.8));  /* Double glow - sharp core, soft outer */
        }

        /* SPEC: Proof Construction Animation (3.5-4.5s total, stepwise)
           Sequence: 1.Central peak → 2.Side peaks → 3.Arc → 4.Terminals
                     → 5.Jewels → 6.Lambda → 7.Verification (QED)
        */
        .crown-peak-center,
        .crown-peak-left,
        .crown-peak-right,
        .crown-arc,
        .crown-terminal-left,
        .crown-terminal-right,
        .crown-jewel-center,
        .crown-jewel-left,
        .crown-jewel-right,
        .lambda-symbol,
        .verification-mark {
            opacity: 0;
            animation: proveIn var(--timing-norm) var(--ease-out-expo) forwards;
        }

        /* SPEC: Stepwise construction spread across 4s */
        .crown-peak-center { animation-delay: 0.5s; }              /* Step 1 */
        .crown-peak-left { animation-delay: 1.0s; }                /* Step 2a */
        .crown-peak-right { animation-delay: 1.0s; }               /* Step 2b (φ-symmetric) */
        .crown-arc { animation-delay: 1.6s; }                      /* Step 3 */
        .crown-terminal-left { animation-delay: 2.1s; }            /* Step 4a */
        .crown-terminal-right { animation-delay: 2.1s; }           /* Step 4b */
        .crown-jewel-center { animation-delay: 2.6s; }             /* Step 5a */
        .crown-jewel-left { animation-delay: 2.9s; }               /* Step 5b */
        .crown-jewel-right { animation-delay: 2.9s; }              /* Step 5c */
        .lambda-symbol { animation-delay: 3.3s; }                  /* Step 6 */
        .verification-mark { animation-delay: 3.8s; }              /* Step 7 (QED moment) */

        @keyframes proveIn {
            /* SPEC: fade/draw with ease-in-out, no bouncy overshoot */
            0% { opacity: 0; transform: translateY(-8px) scale(0.95); filter: blur(2px); }
            100% { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
        }

        /* SPEC: Idle behavior - Very slight glow oscillation (period 6-8s) */
        .crown-jewel-center {
            animation: proveIn var(--timing-norm) var(--ease-out-expo) 2.6s forwards,
                       jewelPulse 7s ease-in-out 5s infinite;
        }

        @keyframes jewelPulse {
            /* SPEC: Rare "proof flash" - one jewel brightens briefly, no constant pulsing */
            0%, 90%, 100% { filter: drop-shadow(0 0 4px rgba(244, 214, 117, 0.5)); }
            95% { filter: drop-shadow(0 0 12px rgba(244, 214, 117, 0.8)); }
        }

        /* Wordmark */
        .wordmark {
            margin-top: 2rem;
            text-align: center;
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 1.6s forwards;
        }

        .wordmark-text {
            font-family: var(--font-display);
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 300;
            letter-spacing: 0.45em;
            color: var(--gold-white);
            margin-left: 0.45em;
            text-shadow: 0 0 40px var(--glow-soft);
        }

        .wordmark-tagline {
            font-family: var(--font-mono);
            font-size: 0.62rem;
            letter-spacing: 0.35em;
            color: var(--gold-dim);
            margin-top: 0.6rem;
        }

        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(25px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ========================================
           THOUGHT BECOMES FORM TRANSFORMATION
        ======================================== */
        .transformation-container {
            position: relative;
            width: 600px;
            height: 400px;
            margin: 3rem auto;
            z-index: 10;
        }

        .thought-symbols {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .thought-symbol {
            position: absolute;
            font-family: var(--font-display);
            font-size: 2.5rem;
            color: var(--gold-dim);
            opacity: 0;
            font-style: italic;
            pointer-events: none;
            filter: blur(2px);
            animation: symbolAppear 0.6s ease-out forwards;
        }

        @keyframes symbolAppear {
            0% {
                opacity: 0;
                transform: scale(0.5) rotate(0deg);
                filter: blur(8px);
            }
            100% {
                opacity: 0.7;
                transform: scale(1) rotate(var(--rotation, 0deg));
                filter: blur(2px);
            }
        }

        .thought-symbol.drifting {
            animation: symbolDrift 2s ease-in-out forwards;
        }

        @keyframes symbolDrift {
            0% {
                opacity: 0.7;
                filter: blur(2px);
            }
            100% {
                opacity: 0.4;
                filter: blur(4px);
                transform: translate(
                    calc(var(--drift-x, 0) * 1px),
                    calc(var(--drift-y, 0) * 1px)
                ) rotate(var(--rotation, 0deg));
            }
        }

        .thought-symbol.converging {
            animation: symbolConverge 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes symbolConverge {
            0% {
                opacity: 0.4;
                filter: blur(4px);
            }
            70% {
                opacity: 0.8;
                filter: blur(0px);
            }
            100% {
                opacity: 0;
                transform: translate(var(--target-x), var(--target-y)) scale(0.3);
                filter: blur(0px);
            }
        }

        .proof-tree {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            transition: opacity 0.8s ease-out;
        }

        .proof-tree.crystallized {
            opacity: 1 !important;
        }

        .proof-line {
            stroke: var(--gold-dim);
            stroke-width: 1.5;
            stroke-dasharray: 200;
            stroke-dashoffset: 200;
            fill: none;
        }

        .proof-tree.crystallized .proof-line {
            animation: drawLine 0.6s ease-out forwards;
        }

        @keyframes drawLine {
            to {
                stroke-dashoffset: 0;
                stroke: var(--gold-core);
            }
        }

        .proof-node {
            fill: var(--gold-shadow);
            stroke: var(--gold-dim);
            stroke-width: 1.5;
            opacity: 0;
        }

        .proof-tree.crystallized .proof-node {
            animation: nodeGlow 0.8s ease-out forwards;
        }

        @keyframes nodeGlow {
            0% {
                opacity: 0;
                transform-origin: center;
                r: 0;
            }
            100% {
                opacity: 1;
                fill: var(--gold-core);
                stroke: var(--gold-bright);
                filter: drop-shadow(0 0 8px var(--glow));
            }
        }

        .proof-node.conclusion {
            r: 8;
        }

        .proof-tree.crystallized .proof-node.conclusion {
            animation: conclusionPulse 1s ease-out 0.8s forwards;
        }

        @keyframes conclusionPulse {
            0% {
                opacity: 0;
                r: 0;
            }
            50% {
                r: 12;
            }
            100% {
                opacity: 1;
                r: 8;
                fill: var(--gold-bright);
                stroke: var(--gold-white);
                filter: drop-shadow(0 0 15px var(--glow-intense));
            }
        }

        .proof-text {
            font-family: var(--font-mono);
            font-size: 16px;
            fill: var(--gold-muted);
            opacity: 0;
        }

        .proof-text.small {
            font-size: 13px;
        }

        .proof-text.conclusion {
            font-size: 18px;
            font-weight: 400;
        }

        .proof-tree.crystallized .proof-text {
            animation: textAppear 0.5s ease-out forwards;
        }

        @keyframes textAppear {
            to {
                opacity: 1;
                fill: var(--gold-white);
            }
        }

        .turnstile-symbol {
            font-family: var(--font-display);
            fill: var(--gold-core);
            opacity: 0;
            font-weight: 300;
        }

        .proof-tree.crystallized .turnstile-symbol {
            animation: turnstileGlow 1s ease-out forwards;
        }

        @keyframes turnstileGlow {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                fill: var(--gold-bright);
                filter: drop-shadow(0 0 20px var(--glow));
            }
        }

        .qed-symbol {
            font-family: var(--font-display);
            font-size: 32px;
            fill: var(--gold-core);
            opacity: 0;
            font-weight: 400;
        }

        .proof-tree.crystallized .qed-symbol {
            animation: qedStamp 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 1.2s forwards;
        }

        @keyframes qedStamp {
            0% {
                opacity: 0;
                transform: scale(2) rotate(-10deg);
                filter: blur(8px);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
                fill: var(--gold-bright);
                filter: blur(0px) drop-shadow(0 0 12px var(--glow));
            }
        }

        /* ========================================
           HERO CONTENT
        ======================================== */
        .hero-content {
            text-align: center;
            max-width: 850px;
            position: relative;
            z-index: 10;
        }

        /* ════════════════════════════════════════
           TYPOGRAPHY: Extreme Tension
           Ultra-light (100) vs Black (800)
           Scale ratio 4x+ between levels
        ════════════════════════════════════════ */
        .hero-headline {
            font-family: var(--font-display);
            font-size: clamp(2.4rem, 6vw, 4.8rem);  /* Larger for presence */
            font-weight: 100;  /* EXTREME light - ethereal, almost fragile */
            letter-spacing: 0.08em;
            line-height: 1.15;
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 1.85s forwards;
            color: var(--gold-white);
        }

        /* Typography Tension: Ultra-light (100) vs Black (800) - DRAMATIC */
        .hero-headline em {
            font-style: normal;
            font-weight: 800;    /* BLACK weight - maximum contrast */
            background: linear-gradient(
                135deg,
                var(--gold-dim) 0%,
                var(--gold-core) 40%,
                var(--gold-bright) 100%
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.01em;  /* Negative tracking for heavy weight */
            /* Subtle inner glow effect via text-shadow on fallback */
        }

        .scramble-text {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            letter-spacing: 0.28em;
            color: var(--gold-muted);
            margin-bottom: 2.5rem;
            min-height: 1.5em;
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 2.05s forwards;
        }

        .scramble-text .char.scrambling {
            color: var(--gold-core);
            text-shadow: 0 0 8px var(--glow);
        }

        /* Concept Tags */
        .concept-tags {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 2.5rem;
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 2.25s forwards;
        }

        .concept-tag {
            padding: 0.65rem 1.6rem;
            border: 1px solid var(--gold-shadow);
            background: rgba(212, 175, 55, 0.02);
            font-family: var(--font-mono);
            font-size: 0.62rem;
            letter-spacing: 0.18em;
            color: var(--gold-muted);
            transition: all 0.4s var(--ease-out-expo);
            position: relative;
            overflow: hidden;
        }

        .concept-tag::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(212,175,55,0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s var(--ease-out-expo);
        }

        .concept-tag:hover {
            border-color: var(--gold-core);
            color: var(--gold-white);
            background: rgba(212, 175, 55, 0.06);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 20px var(--glow-soft);
        }

        .concept-tag:hover::before {
            transform: translateX(100%);
        }

        /* CTA Button */
        .cta-button {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            padding: 1.1rem 2.8rem;
            border: 1px solid var(--gold-dim);
            background: transparent;
            font-family: var(--font-mono);
            font-size: 0.72rem;
            letter-spacing: 0.22em;
            color: var(--gold-white);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s var(--ease-out-expo);
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 2.45s forwards;
        }

        .cta-button::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--gold-core);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.5s var(--ease-out-expo);
            z-index: -1;
        }

        .cta-button:hover {
            color: var(--void);
            border-color: var(--gold-core);
            box-shadow: 0 0 40px var(--glow), 0 15px 40px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        .cta-button:hover::before {
            transform: scaleX(1);
        }

        .cta-icon {
            width: 18px;
            height: 18px;
            border: 1px solid currentColor;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            transition: transform 0.3s ease;
        }

        .cta-button:hover .cta-icon {
            transform: rotate(45deg);
        }

        /* Scroll Indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 2.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.6rem;
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 2.8s forwards;
        }

        .scroll-track {
            width: 1px;
            height: 55px;
            background: var(--gold-shadow);
            position: relative;
            overflow: hidden;
        }

        .scroll-pulse {
            position: absolute;
            top: -20px;
            left: 0;
            width: 100%;
            height: 20px;
            background: linear-gradient(to bottom, transparent, var(--gold-core), transparent);
            animation: scrollPulse 2.2s ease-in-out infinite;
        }

        @keyframes scrollPulse {
            0% { top: -20px; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 55px; opacity: 0; }
        }

        .scroll-label {
            font-family: var(--font-mono);
            font-size: 0.52rem;
            letter-spacing: 0.25em;
            color: var(--gold-dim);
        }

        /* ========================================
           SECTIONS - Enhanced with Parallax
        ======================================== */
        section {
            padding: 10rem 2.5rem;  /* More generous vertical rhythm */
            max-width: 1320px;  /* Slightly narrower for better readability */
            margin: 0 auto;
            position: relative;
            will-change: transform;
        }

        /* Reveal animations */
        .reveal {
            opacity: 0;
            transform: translateY(40px);
            transition: all 0.8s var(--ease-out-expo);
        }

        .reveal.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Parallax layers */
        [data-parallax] {
            will-change: transform;
        }

        /* Section Header - Refined spacing rhythm */
        .section-header {
            text-align: center;
            margin-bottom: 5rem;  /* More breathing room */
        }

        .section-number {
            font-family: var(--font-mono);
            font-size: 0.55rem;
            letter-spacing: 0.4em;
            color: var(--gold-dim);  /* Slightly brighter for hierarchy */
            margin-bottom: 1.5rem;
            display: block;
            opacity: 0.7;
        }

        .section-title {
            font-family: var(--font-display);
            font-size: clamp(2.2rem, 5vw, 3.2rem);  /* Slightly larger */
            font-weight: 200;  /* Ultra-light for elegance */
            letter-spacing: 0.25em;
            margin-bottom: 1.5rem;
            text-transform: uppercase;
            color: var(--gold-white);
        }

        .section-subtitle {
            font-size: 0.95rem;
            color: var(--gold-muted);
            max-width: 580px;
            margin: 0 auto;
            line-height: 1.95;
            letter-spacing: 0.02em;
        }

        .divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-shadow), transparent);
            margin: 0 2rem;
        }

        /* ========================================
           FEATURE CARDS - HOLOGRAPHIC
        ======================================== */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2rem;
        }

        .feature-card {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.02), rgba(0, 0, 0, 0.4));
            border: 1px solid var(--border);
            padding: 2.5rem;
            position: relative;
            overflow: hidden;
            transition: all 0.5s var(--ease-out-expo);
            transform-style: preserve-3d;
            perspective: 1000px;
            cursor: pointer;
            will-change: transform, box-shadow;
        }

        .feature-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(
                ellipse at var(--mouse-x, 50%) var(--mouse-y, 50%),
                rgba(212, 175, 55, 0.12),
                transparent 50%
            );
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .feature-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                from 0deg,
                transparent,
                rgba(212, 175, 55, 0.08),
                transparent 30%
            );
            animation: cardRotate 8s linear infinite;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        @keyframes cardRotate {
            to { transform: rotate(360deg); }
        }

        .feature-card:hover {
            border-color: var(--gold-muted);
            transform: translateY(-8px) rotateX(2deg) rotateY(-1deg);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.4),
                0 0 50px var(--glow-soft),
                inset 0 0 50px rgba(212, 175, 55, 0.02);
        }

        .feature-card:hover::before,
        .feature-card:hover::after {
            opacity: 1;
        }

        .feature-content {
            position: relative;
            z-index: 1;
        }

        .feature-icon {
            width: 55px;
            height: 55px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
            position: relative;
        }

        .feature-icon::before {
            content: '';
            position: absolute;
            inset: 0;
            border: 1px solid var(--gold-dim);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            opacity: 0.5;
            animation: iconPulse 4s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        .feature-icon-inner {
            font-size: 1.6rem;
            filter: drop-shadow(0 0 12px var(--glow));
        }

        .feature-title {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            margin-bottom: 0.8rem;
        }

        .feature-desc {
            font-size: 0.88rem;
            color: var(--gold-muted);
            line-height: 1.85;
        }

        /* ════════════════════════════════════════════════════════════════
           BRIEFING DOSSIER SYSTEM
           Plates, not blocks. Chapters, not sections.
           The page is a classified briefing advancing toward one action.
        ════════════════════════════════════════════════════════════════ */

        /* Hold Frame - persistent ritual backdrop */
        .hold-frame {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: -1;
            pointer-events: none;
        }

        .hold-frame::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(
                ellipse at 50% 30%,
                rgba(42, 34, 16, 0.4) 0%,
                rgba(8, 8, 8, 0.95) 70%
            );
        }

        /* Briefing Container */
        .briefing-dossier {
            position: relative;
            z-index: 1;
            background: transparent;
        }

        /* Chapter Plate - lab panel aesthetic */
        .chapter-plate {
            position: relative;
            max-width: 1100px;
            margin: 0 auto;
            padding: 6rem 3rem;
            border-left: 1px solid var(--gold-shadow);
            border-right: 1px solid var(--gold-shadow);
            background: linear-gradient(
                180deg,
                rgba(8, 8, 8, 0.85) 0%,
                rgba(12, 12, 10, 0.9) 50%,
                rgba(8, 8, 8, 0.85) 100%
            );
        }

        .chapter-plate::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent 20%, var(--gold-shadow) 50%, transparent 80%);
        }

        .chapter-plate::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent 20%, var(--gold-shadow) 50%, transparent 80%);
        }

        /* Chapter Code Rail */
        .chapter-code {
            position: absolute;
            left: 2rem;
            top: 3rem;
            font-family: var(--font-mono);
            font-size: 0.6rem;
            letter-spacing: 0.2em;
            color: var(--gold-dim);
            writing-mode: vertical-lr;
            transform: rotate(180deg);
            opacity: 0.6;
        }

        /* Chapter Content */
        .chapter-content {
            max-width: 720px;
            margin: 0 auto;
            padding-left: 2rem;
        }

        /* Chapter Stamp - the single word that brands each chapter */
        .chapter-stamp {
            font-family: var(--font-display);
            font-size: clamp(1.8rem, 4vw, 2.6rem);
            font-weight: 200;
            letter-spacing: 0.15em;
            color: var(--gold-core);
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s var(--ease-out-expo);
        }

        .chapter-plate.revealed .chapter-stamp {
            opacity: 1;
            transform: translateY(0);
        }

        /* Chapter Claim - one sentence, authoritative */
        .chapter-claim {
            font-family: var(--font-body);
            font-size: 1.1rem;
            font-weight: 300;
            line-height: 1.8;
            color: var(--gold-white);
            margin-bottom: 2.5rem;
            max-width: 580px;
            opacity: 0;
            transform: translateY(15px);
            transition: all 0.5s var(--ease-out-expo) 0.1s;
        }

        .chapter-plate.revealed .chapter-claim {
            opacity: 1;
            transform: translateY(0);
        }

        /* Chapter Artifact - conceptual visual, not technical */
        .chapter-artifact {
            position: relative;
            margin: 2.5rem 0;
            padding: 2rem;
            border: 1px solid var(--gold-shadow);
            background: rgba(212, 175, 55, 0.015);
            opacity: 0;
            transform: translateY(15px);
            transition: all 0.5s var(--ease-out-expo) 0.2s;
        }

        .chapter-plate.revealed .chapter-artifact {
            opacity: 1;
            transform: translateY(0);
        }

        .artifact-label {
            position: absolute;
            top: -0.6rem;
            left: 1.5rem;
            font-family: var(--font-mono);
            font-size: 0.55rem;
            letter-spacing: 0.25em;
            color: var(--gold-dim);
            background: var(--void);
            padding: 0 0.5rem;
        }

        .artifact-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100px;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--gold-muted);
            letter-spacing: 0.1em;
        }

        .artifact-visual svg {
            max-width: 100%;
            height: auto;
        }

        /* Chapter Consequence - one line result */
        .chapter-consequence {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            letter-spacing: 0.12em;
            color: var(--gold-dim);
            padding-left: 1.5rem;
            border-left: 2px solid var(--gold-shadow);
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(15px);
            transition: all 0.5s var(--ease-out-expo) 0.3s;
        }

        .chapter-plate.revealed .chapter-consequence {
            opacity: 1;
            transform: translateY(0);
        }

        .chapter-consequence strong {
            color: var(--gold-core);
            font-weight: 400;
        }

        /* Progressive Disclosure - Expand */
        .chapter-expand {
            margin-top: 1.5rem;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.4s var(--ease-out-expo) 0.4s;
        }

        .chapter-plate.revealed .chapter-expand {
            opacity: 1;
            transform: translateY(0);
        }

        .expand-trigger {
            font-family: var(--font-mono);
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            color: var(--gold-dim);
            background: transparent;
            border: 1px solid var(--gold-shadow);
            padding: 0.6rem 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .expand-trigger:hover {
            border-color: var(--gold-core);
            color: var(--gold-core);
        }

        .expand-trigger .arrow {
            transition: transform 0.3s ease;
        }

        .expand-trigger.open .arrow {
            transform: rotate(180deg);
        }

        .expand-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s var(--ease-out-expo);
        }

        .expand-content.open {
            max-height: 500px;
        }

        .expand-inner {
            padding: 2rem 0;
            border-top: 1px solid var(--gold-shadow);
            margin-top: 1.5rem;
        }

        .expand-bullets {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .expand-bullets li {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--gold-muted);
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
            line-height: 1.6;
        }

        .expand-bullets li::before {
            content: '>';
            position: absolute;
            left: 0;
            color: var(--gold-dim);
        }

        /* Conversion Gates */
        .gate-soft {
            text-align: center;
            padding: 4rem 2rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .gate-soft .gate-line {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            color: var(--gold-dim);
            margin-bottom: 1.5rem;
        }

        .gate-soft .gate-cta {
            display: inline-block;
            font-family: var(--font-mono);
            font-size: 0.65rem;
            letter-spacing: 0.18em;
            color: var(--gold-core);
            border: 1px solid var(--gold-dim);
            padding: 0.8rem 1.8rem;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .gate-soft .gate-cta:hover {
            background: var(--gold-core);
            color: var(--void);
            border-color: var(--gold-core);
        }

        /* Hard Gate - Final CTA */
        .gate-hard {
            text-align: center;
            padding: 6rem 2rem;
            background: linear-gradient(
                180deg,
                transparent 0%,
                rgba(212, 175, 55, 0.02) 50%,
                transparent 100%
            );
        }

        .gate-hard .gate-stamp {
            font-family: var(--font-display);
            font-size: clamp(1.4rem, 3vw, 2rem);
            font-weight: 200;
            letter-spacing: 0.2em;
            color: var(--gold-white);
            margin-bottom: 1.5rem;
        }

        .gate-hard .gate-subline {
            font-family: var(--font-body);
            font-size: 0.95rem;
            color: var(--gold-muted);
            margin-bottom: 2.5rem;
            max-width: 480px;
            margin-left: auto;
            margin-right: auto;
        }

        .gate-hard .gate-cta-primary {
            display: inline-block;
            font-family: var(--font-mono);
            font-size: 0.72rem;
            letter-spacing: 0.2em;
            color: var(--void);
            background: var(--gold-core);
            border: 1px solid var(--gold-core);
            padding: 1.1rem 2.5rem;
            text-decoration: none;
            transition: all 0.4s var(--ease-out-expo);
            position: relative;
            overflow: hidden;
        }

        .gate-hard .gate-cta-primary:hover {
            background: var(--gold-bright);
            box-shadow: 0 0 40px var(--glow), 0 15px 40px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }

        /* Portfolio Card (for Cythector) */
        .portfolio-card {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
            padding: 2rem;
            border: 1px solid var(--gold-shadow);
            background: rgba(212, 175, 55, 0.01);
            transition: all 0.3s ease;
        }

        .portfolio-card:hover {
            border-color: var(--gold-dim);
        }

        .portfolio-logo {
            width: 80px;
            height: 80px;
            flex-shrink: 0;
        }

        .portfolio-logo img {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.2));
        }

        .portfolio-info h4 {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: 400;
            letter-spacing: 0.1em;
            color: var(--gold-white);
            margin-bottom: 0.5rem;
        }

        .portfolio-info p {
            font-size: 0.85rem;
            color: var(--gold-muted);
            line-height: 1.7;
            margin-bottom: 1rem;
        }

        .portfolio-link {
            font-family: var(--font-mono);
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            color: var(--gold-core);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
        }

        .portfolio-link:hover {
            color: var(--gold-bright);
        }

        /* Calibration Mark - chapter entry ritual element */
        .calibration-mark {
            position: absolute;
            left: 50%;
            top: 2rem;
            transform: translateX(-50%);
            width: 40px;
            height: 1px;
            background: var(--gold-dim);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .chapter-plate.revealed .calibration-mark {
            opacity: 1;
        }

        /* Responsive adjustments for plates */
        @media (max-width: 768px) {
            .chapter-plate {
                padding: 4rem 1.5rem;
                border-left: none;
                border-right: none;
            }

            .chapter-code {
                position: relative;
                left: 0;
                top: 0;
                writing-mode: horizontal-tb;
                transform: none;
                margin-bottom: 1.5rem;
            }

            .chapter-content {
                padding-left: 0;
            }

            .portfolio-card {
                flex-direction: column;
                text-align: center;
            }

            .portfolio-logo {
                margin: 0 auto;
            }
        }

        /* ========================================
           CONTACT SECTION
        ======================================== */
        .contact-grid {
            display: grid;
            grid-template-columns: 1.5fr 1fr;
            gap: 2rem;
        }

        .contact-card {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.02), rgba(0, 0, 0, 0.3));
            border: 1px solid var(--border);
            padding: 2.2rem;
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .contact-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold-core), transparent);
            animation: cardShine 5s ease-in-out infinite;
        }

        @keyframes cardShine {
            0%, 100% { left: -100%; }
            50% { left: 100%; }
        }

        .contact-card:hover {
            border-color: var(--gold-dim);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .contact-label {
            font-family: var(--font-mono);
            font-size: 0.58rem;
            letter-spacing: 0.22em;
            color: var(--gold-dim);
            padding: 0.35rem 0.9rem;
            border: 1px solid var(--gold-shadow);
            display: inline-block;
            margin-bottom: 1.2rem;
        }

        .contact-title {
            font-family: var(--font-display);
            font-size: 1.45rem;
            font-weight: 300;
            letter-spacing: 0.12em;
            margin-bottom: 1.5rem;
        }

        .contact-email {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            color: var(--gold-core);
            margin-bottom: 1.5rem;
            display: block;
        }

        .btn {
            padding: 0.8rem 1.5rem;
            border: 1px solid var(--gold-dim);
            background: transparent;
            font-family: var(--font-mono);
            font-size: 0.68rem;
            letter-spacing: 0.15em;
            color: var(--gold-white);
            cursor: pointer;
            transition: all 0.35s var(--ease-out-expo);
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--gold-core);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.4s var(--ease-out-expo);
            z-index: -1;
        }

        .btn:hover {
            color: var(--void);
            border-color: var(--gold-core);
            box-shadow: 0 0 25px var(--glow-soft);
        }

        .btn:hover::before {
            transform: scaleX(1);
        }

        .form-grid {
            display: grid;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .form-input,
        .form-textarea {
            width: 100%;
            padding: 0.95rem 1.1rem;
            background: rgba(212, 175, 55, 0.02);
            border: 1px solid var(--border);
            color: var(--gold-white);
            font-family: var(--font-body);
            font-size: 0.88rem;
            outline: none;
            transition: all 0.35s ease;
        }

        .form-input:focus,
        .form-textarea:focus {
            border-color: var(--gold-core);
            box-shadow: 0 0 25px var(--glow-soft);
            background: rgba(212, 175, 55, 0.04);
        }

        .form-input::placeholder,
        .form-textarea::placeholder {
            color: var(--gold-dim);
        }

        .form-textarea {
            min-height: 110px;
            resize: vertical;
        }

        .status-list {
            list-style: none;
            margin: 1.5rem 0;
        }

        .status-item {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--gold-muted);
            padding: 0.45rem 0;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .status-item::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--gold-core);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--glow);
            animation: statusPulse 2s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .status-item strong {
            color: var(--gold-bright);
            font-weight: 400;
        }

        /* ========================================
           FOOTER
        ======================================== */
        footer {
            max-width: 1400px;
            margin: 4rem auto 0;
            padding: 2rem;
            border-top: 1px solid var(--gold-shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .footer-brand {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .footer-brand svg {
            width: 24px;
            height: 28px;
            opacity: 0.7;
        }

        .footer-brand-text {
            font-family: var(--font-mono);
            font-size: 0.68rem;
            letter-spacing: 0.18em;
            color: var(--gold-dim);
        }

        .footer-links {
            display: flex;
            gap: 2rem;
            font-family: var(--font-mono);
            font-size: 0.62rem;
            color: var(--gold-muted);
        }

        /* ========================================
           LOADING SCREEN
        ======================================== */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: var(--void);
            z-index: 20000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2.5rem;
            transition: opacity 1s ease, visibility 1s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        /* DNA Helix Loading */
        .dna-helix {
            width: 80px;
            height: 160px;
            position: relative;
            perspective: 800px;
        }

        .dna-strand {
            position: absolute;
            inset: 0;
            transform-style: preserve-3d;
            animation: dnaRotate 3.5s linear infinite;
        }

        .dna-base {
            position: absolute;
            width: 70%;
            height: 2px;
            background: linear-gradient(90deg, var(--gold-dim), var(--gold-core), var(--gold-dim));
            left: 15%;
            border-radius: 1px;
        }

        @keyframes dnaRotate {
            to { transform: rotateY(360deg); }
        }

        .loading-text {
            font-family: var(--font-mono);
            font-size: 0.62rem;
            letter-spacing: 0.35em;
            color: var(--gold-dim);
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* ========================================
           REVEAL ANIMATIONS
        ======================================== */
        .reveal {
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.9s var(--ease-out-expo);
        }

        .reveal.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* ========================================
           RESPONSIVE
        ======================================== */
        @media (max-width: 1100px) {
            .awakening-meter { display: none; }
            .contact-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            nav { padding: 1rem 1.5rem; }
            .nav-links { display: none; }
            .hero { padding: 5rem 1.5rem 3rem; }
            .integrated-crown { width: 150px; height: 180px; }
            .sacred-geometry { width: 400px; height: 400px; }
            section { padding: 4rem 1.5rem; }
            .feature-grid { grid-template-columns: 1fr; }
            .cursor-core, .cursor-aura { display: none; }
            html { cursor: auto; }
            .concept-tags { flex-direction: column; align-items: center; }
            .ambient-orb { display: none; }
            .transformation-container {
                width: 90%;
                max-width: 400px;
                height: 300px;
                margin: 2rem auto;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* ========================================
           CYTHECTOR SECTION - Enhanced Refinements
        ======================================== */
        #cythector .section-header {
            animation: fadeSlideUp 1s var(--ease-out-expo) forwards;
        }

        @keyframes fadeSlideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #cythector img[src*="cythector_logo"] {
            transition: all 0.6s var(--ease-out-expo);
            animation: logoFloat 6s ease-in-out infinite;
            will-change: transform;
        }

        @keyframes logoFloat {
            0%, 100% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
            25% {
                transform: translateY(-8px) rotate(2deg) scale(1.02);
            }
            50% {
                transform: translateY(0) rotate(0deg) scale(1);
            }
            75% {
                transform: translateY(-5px) rotate(-2deg) scale(1.01);
            }
        }

        #cythector img[src*="cythector_logo"]:hover {
            transform: scale(1.15) translateY(-10px) !important;
            filter: drop-shadow(0 0 40px rgba(212, 175, 55, 0.6)) !important;
            animation-play-state: paused;
        }

        #cythector .feature-card {
            opacity: 0;
            transform: translateY(30px);
            animation: cascadeIn 0.7s var(--ease-out-expo) forwards;
        }

        #cythector .feature-card:nth-child(1) {
            animation-delay: 0.2s;
        }

        #cythector .feature-card:nth-child(2) {
            animation-delay: 0.4s;
        }

        #cythector .feature-card:nth-child(3) {
            animation-delay: 0.6s;
        }

        @keyframes cascadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Enhanced bot link button */
        #cythector a[href*="/bots/cythector/"] {
            position: relative;
            overflow: hidden;
            color: var(--gold-core);
            text-decoration: none;
            font-weight: 500;
            font-size: 1.1rem;
            border: 1px solid var(--gold-dim);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            display: inline-block;
            transition: all 0.4s var(--ease-out-expo);
            background: rgba(212, 175, 55, 0.03);
        }

        #cythector a[href*="/bots/cythector/"]::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(212, 175, 55, 0.2), transparent 70%);
            transform: translate(-50%, -50%);
            transition: all 0.5s var(--ease-out-expo);
            border-radius: 50%;
        }

        #cythector a[href*="/bots/cythector/"]:hover {
            color: var(--gold-white);
            border-color: var(--gold-core);
            background: rgba(212, 175, 55, 0.08);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.2);
        }

        #cythector a[href*="/bots/cythector/"]:hover::before {
            width: 300px;
            height: 300px;
        }

        /* ========================================
           2025 CUTTING-EDGE ENHANCEMENTS
           Morphic Resonance, Liquid Glass, Quantum Threads
        ======================================== */

        /* MORPHIC RESONANCE FIELD - Interconnected consciousness threads */
        .morphic-field {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 5;
            opacity: 0.15;
            mix-blend-mode: screen;
        }

        .morphic-thread {
            position: absolute;
            background: linear-gradient(90deg, transparent, var(--gold-core), transparent);
            height: 1px;
            transform-origin: left center;
            animation: morphicPulse 8s ease-in-out infinite;
            filter: blur(0.5px);
        }

        @keyframes morphicPulse {
            0%, 100% { opacity: 0.3; filter: blur(0.5px) drop-shadow(0 0 2px var(--gold-core)); }
            50% { opacity: 0.8; filter: blur(0px) drop-shadow(0 0 8px var(--gold-bright)); }
        }

        /* FIBONACCI GOLDEN SPIRAL - Sacred geometry overlay */
        .golden-spiral {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 900px;
            height: 900px;
            pointer-events: none;
            opacity: 0.04;
            animation: spiralRotate 120s linear infinite;
        }

        .golden-spiral svg {
            width: 100%;
            height: 100%;
        }

        @keyframes spiralRotate {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* ════════════════════════════════════════
           REFINED GLASS - Architectural Clarity
           Minimal blur, maximum definition
        ════════════════════════════════════════ */
        .liquid-glass {
            background: linear-gradient(
                135deg,
                rgba(10, 10, 15, 0.92) 0%,
                rgba(15, 15, 20, 0.88) 100%
            );
            backdrop-filter: blur(6px);  /* Subtle - material honesty */
            -webkit-backdrop-filter: blur(6px);
            border: 1px solid var(--gold-shadow);
            box-shadow:
                0 4px 24px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(212, 175, 55, 0.05);
            position: relative;
            overflow: hidden;
        }

        /* Removed shimmer animation - restraint as distinction */
        .liquid-glass::before { display: none; }

        /* Nav maintains architectural consistency */
        nav.liquid-glass-nav {
            background: linear-gradient(
                180deg,
                rgba(5, 5, 8, 0.96) 0%,
                rgba(5, 5, 8, 0.92) 100%
            ) !important;
            backdrop-filter: blur(8px) !important;
            -webkit-backdrop-filter: blur(8px) !important;
            border-bottom: 1px solid var(--gold-shadow) !important;
        }

        /* QUANTUM ENTANGLEMENT THREADS */
        .quantum-threads {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 4;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .quantum-threads.active {
            opacity: 0.12;
        }

        .quantum-thread {
            position: absolute;
            stroke: url(#quantumGradient);
            stroke-width: 0.5;
            fill: none;
            opacity: 0;
            animation: quantumEntangle 4s ease-in-out infinite;
        }

        @keyframes quantumEntangle {
            0%, 100% { opacity: 0; stroke-dashoffset: 100; }
            25% { opacity: 0.8; }
            75% { opacity: 0.8; }
            50% { stroke-dashoffset: 0; }
        }

        /* CHROMATIC ABERRATION HOVER */
        .chromatic-hover {
            position: relative;
        }

        .chromatic-hover::before,
        .chromatic-hover::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            pointer-events: none;
        }

        .chromatic-hover::before {
            color: rgba(255, 0, 0, 0.5);
            animation: chromaticR 0.1s ease-out forwards;
        }

        .chromatic-hover::after {
            color: rgba(0, 255, 255, 0.5);
            animation: chromaticC 0.1s ease-out forwards;
        }

        .chromatic-hover:hover::before {
            opacity: 0.7;
            transform: translate(-2px, 0);
        }

        .chromatic-hover:hover::after {
            opacity: 0.7;
            transform: translate(2px, 0);
        }

        /* BREATH ANIMATION - Site-wide consciousness pulse */
        @keyframes consciousnessBreath {
            0%, 100% {
                filter: brightness(1) drop-shadow(0 0 0px transparent);
            }
            50% {
                filter: brightness(1.02) drop-shadow(0 0 30px rgba(212, 175, 55, 0.08));
            }
        }

        .breathing {
            animation: consciousnessBreath 6s ease-in-out infinite;
        }

        /* Site-wide subtle pulse */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at 50% 50%, rgba(212, 175, 55, 0.03) 0%, transparent 70%);
            pointer-events: none;
            z-index: 1;
            animation: siteBreath 8s ease-in-out infinite;
        }

        @keyframes siteBreath {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        /* DATA STREAM VISUALIZATION */
        .data-stream {
            position: absolute;
            font-family: var(--font-mono);
            font-size: 8px;
            color: var(--gold-shadow);
            white-space: nowrap;
            opacity: 0.15;
            pointer-events: none;
            animation: dataFlow 20s linear infinite;
        }

        @keyframes dataFlow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100vw); }
        }

        .data-stream-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 2;
            opacity: 0.3;
        }

        /* HOLOGRAPHIC SHIMMER - Rainbow refraction on cards */
        .feature-card::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                from 0deg,
                transparent,
                rgba(212, 175, 55, 0.08),
                rgba(255, 215, 0, 0.04),
                rgba(218, 165, 32, 0.06),
                rgba(184, 134, 11, 0.04),
                transparent 30%
            );
            animation: cardRotate 8s linear infinite, holographicShift 4s ease-in-out infinite;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .feature-card:hover::after {
            opacity: 1;
        }

        @keyframes holographicShift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(15deg); }
        }

        /* Additional holographic overlay */
        .feature-card .holo-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(
                45deg,
                transparent 30%,
                rgba(212, 175, 55, 0.05) 45%,
                rgba(255, 215, 0, 0.08) 50%,
                rgba(212, 175, 55, 0.05) 55%,
                transparent 70%
            );
            background-size: 200% 200%;
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
            animation: holoMove 3s ease-in-out infinite;
        }

        .feature-card:hover .holo-overlay {
            opacity: 1;
        }

        @keyframes holoMove {
            0% { background-position: -100% -100%; }
            100% { background-position: 200% 200%; }
        }

        /* ADVANCED GLOW TYPOGRAPHY */
        .glow-text {
            text-shadow:
                0 0 10px rgba(212, 175, 55, 0.3),
                0 0 20px rgba(212, 175, 55, 0.2),
                0 0 30px rgba(212, 175, 55, 0.1),
                0 0 40px rgba(212, 175, 55, 0.05);
            animation: textGlow 4s ease-in-out infinite;
        }

        @keyframes textGlow {
            0%, 100% {
                text-shadow:
                    0 0 10px rgba(212, 175, 55, 0.3),
                    0 0 20px rgba(212, 175, 55, 0.2),
                    0 0 30px rgba(212, 175, 55, 0.1);
            }
            50% {
                text-shadow:
                    0 0 15px rgba(212, 175, 55, 0.5),
                    0 0 30px rgba(212, 175, 55, 0.3),
                    0 0 45px rgba(212, 175, 55, 0.2),
                    0 0 60px rgba(212, 175, 55, 0.1);
            }
        }

        /* Enhanced hero headline glow */
        .hero-headline em {
            animation: heroEmGlow 5s ease-in-out infinite;
        }

        @keyframes heroEmGlow {
            0%, 100% { filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.4)); }
            50% { filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.7)); }
        }

        /* ATMOSPHERIC DEPTH FOG */
        .depth-fog {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 3;
        }

        .fog-layer {
            position: absolute;
            inset: 0;
            background: radial-gradient(
                ellipse 150% 100% at 50% 100%,
                rgba(5, 5, 8, 0.7) 0%,
                transparent 50%
            );
            animation: fogDrift 30s ease-in-out infinite;
        }

        .fog-layer:nth-child(2) {
            background: radial-gradient(
                ellipse 100% 80% at 30% 80%,
                rgba(5, 5, 8, 0.4) 0%,
                transparent 40%
            );
            animation-delay: -15s;
            animation-duration: 40s;
        }

        .fog-layer:nth-child(3) {
            background: radial-gradient(
                ellipse 120% 60% at 70% 90%,
                rgba(5, 5, 8, 0.3) 0%,
                transparent 35%
            );
            animation-delay: -8s;
            animation-duration: 35s;
        }

        @keyframes fogDrift {
            0%, 100% { transform: translateX(-5%) translateY(5%); opacity: 0.6; }
            50% { transform: translateX(5%) translateY(-2%); opacity: 0.8; }
        }

        /* ENERGY PULSE RINGS */
        .energy-rings {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 6;
        }

        .energy-ring {
            position: absolute;
            border: 1px solid rgba(212, 175, 55, 0.15);
            border-radius: 50%;
            animation: energyExpand 6s ease-out infinite;
            opacity: 0;
        }

        .energy-ring:nth-child(1) { animation-delay: 0s; }
        .energy-ring:nth-child(2) { animation-delay: 1.5s; }
        .energy-ring:nth-child(3) { animation-delay: 3s; }
        .energy-ring:nth-child(4) { animation-delay: 4.5s; }

        @keyframes energyExpand {
            0% {
                width: 100px;
                height: 100px;
                margin-left: -50px;
                margin-top: -50px;
                opacity: 0.6;
                border-color: rgba(212, 175, 55, 0.4);
            }
            100% {
                width: 800px;
                height: 800px;
                margin-left: -400px;
                margin-top: -400px;
                opacity: 0;
                border-color: rgba(212, 175, 55, 0);
            }
        }

        /* CONSCIOUSNESS PARTICLES */
        .consciousness-particles {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 7;
            overflow: hidden;
        }

        .c-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--gold-core);
            border-radius: 50%;
            opacity: 0;
            animation: consciousnessFloat 15s ease-in-out infinite;
            box-shadow: 0 0 6px var(--gold-core), 0 0 12px rgba(212, 175, 55, 0.3);
        }

        @keyframes consciousnessFloat {
            0% {
                opacity: 0;
                transform: translateY(100vh) translateX(0) scale(0);
            }
            10% {
                opacity: 0.8;
                transform: translateY(80vh) translateX(10px) scale(1);
            }
            90% {
                opacity: 0.8;
                transform: translateY(10vh) translateX(-10px) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-10vh) translateX(0) scale(0);
            }
        }

        /* HEXAGONAL GRID OVERLAY */
        .hex-grid {
            position: absolute;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='49' viewBox='0 0 28 49'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%23d4af37' fill-opacity='0.02'%3E%3Cpath d='M13.99 9.25l13 7.5v15l-13 7.5L1 31.75v-15l12.99-7.5zM3 17.9v12.7l10.99 6.34 11-6.35V17.9l-11-6.34L3 17.9zM0 15l12.98-7.5V0h-2v6.35L0 12.69v2.3zm0 18.5L12.98 41v8h-2v-6.85L0 35.81v-2.3zM15 0v7.5L27.99 15H28v-2.31h-.01L17 6.35V0h-2zm0 49v-8l12.99-7.5H28v2.31h-.01L17 42.15V49h-2z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            pointer-events: none;
            opacity: 0.3;
            animation: hexShift 60s linear infinite;
        }

        @keyframes hexShift {
            0% { background-position: 0 0; }
            100% { background-position: 280px 490px; }
        }

        /* SECTION REVEAL ENHANCEMENTS */
        .reveal {
            position: relative;
        }

        .reveal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            height: 80px;
            background: linear-gradient(to bottom, transparent, var(--gold-dim), transparent);
            opacity: 0;
            transition: opacity 0.8s ease 0.3s;
        }

        .reveal.active::before {
            opacity: 0.5;
        }

        /* ENHANCED SCROLL INDICATOR */
        .scroll-indicator::before {
            content: '';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border: 1px solid rgba(212, 175, 55, 0.1);
            border-radius: 50%;
            animation: scrollRing 3s ease-in-out infinite;
        }

        @keyframes scrollRing {
            0%, 100% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.2); opacity: 0.5; }
        }

        /* NOISE TEXTURE OVERLAY */
        .noise-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9996;
            opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='1'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
        }

        /* RESPONSIVE ADJUSTMENTS FOR NEW FEATURES */
        @media (max-width: 768px) {
            .morphic-field,
            .quantum-threads,
            .data-stream-container,
            .depth-fog,
            .consciousness-particles,
            .energy-rings,
            .golden-spiral,
            .hex-grid {
                display: none;
            }

            body::before {
                display: none;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            .morphic-field,
            .quantum-threads,
            .data-stream-container,
            .depth-fog,
            .consciousness-particles,
            .energy-rings,
            .golden-spiral,
            .hex-grid,
            .noise-overlay {
                display: none !important;
            }

            body::before,
            .feature-card::after,
            .feature-card .holo-overlay,
            .liquid-glass::before {
                animation: none !important;
                display: none !important;
            }
        }

        /* ════════════════════════════════════════════════════════════════
           REALITY TEASER ENGINE
           Cinematic one-pass experience. Not a SaaS surface.
           Memorable + credible in one pass.
        ════════════════════════════════════════════════════════════════ */

        /* Hide all SaaS surface elements - Teaser mode */
        .trust-strip,
        .trust-inspector,
        .metrics-strip,
        .proof-interface,
        .proof-receipt,
        .team-credentials,
        .instrumentation-grid,
        .corner-bracket,
        .tech-annotation,
        .hero-cta-group,
        .hero-technical-subheadline,
        .passive-demo-indicator,
        .nav-persona-switch,
        .awakening-meter,
        .loading-screen,
        .verification-flash,
        .cursor-lens-info {
            display: none !important;
        }

        /* ═══════════════════════════════════════
           RITUAL STAGE - Containment Chamber
        ═══════════════════════════════════════ */
        .ritual-stage {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 400px;
            margin: 3rem auto;
            border: 1px solid var(--gold-shadow);
            border-radius: 8px;
            overflow: hidden;
            background: radial-gradient(ellipse at 50% 50%,
                rgba(212, 175, 55, 0.03) 0%,
                transparent 70%);
        }

        .ritual-stage::before {
            content: '';
            position: absolute;
            inset: 0;
            border: 1px solid transparent;
            border-radius: 8px;
            background: linear-gradient(135deg,
                rgba(212, 175, 55, 0.1) 0%,
                transparent 50%,
                rgba(212, 175, 55, 0.05) 100%);
            mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            pointer-events: none;
        }

        /* Phase indicator - transient, not permanent chrome */
        .ritual-phase-indicator {
            position: absolute;
            top: 16px;
            left: 16px;
            font-family: var(--font-mono);
            font-size: 10px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--gold-dim);
            opacity: 0;
            transition: opacity 0.3s ease, color 0.3s ease;
        }

        .ritual-phase-indicator.visible {
            opacity: 1;
        }

        .ritual-phase-indicator[data-phase="random"] {
            color: var(--phase-random);
        }

        .ritual-phase-indicator[data-phase="converge"] {
            color: var(--phase-converge);
        }

        .ritual-phase-indicator[data-phase="emerge"] {
            color: var(--phase-emerge);
        }

        .ritual-phase-indicator[data-phase="lock"] {
            color: var(--phase-lock);
        }

        /* Ritual message - flashes and fades */
        .ritual-message {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--font-mono);
            font-size: 12px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--gold);
            opacity: 0;
            transition: opacity 0.5s ease;
            white-space: nowrap;
        }

        .ritual-message.visible {
            opacity: 1;
        }

        /* Ritual stamp - single seal at Lock moment */
        .ritual-stamp {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: var(--font-mono);
            font-size: 14px;
            font-weight: var(--weight-medium);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--gold);
            opacity: 0;
            transition: opacity 0.6s var(--ease-out-expo);
            white-space: nowrap;
            text-shadow: 0 0 30px var(--glow);
            z-index: 10;
        }

        .ritual-stamp.visible {
            opacity: 1;
            animation: stampPulse 1.5s ease-out forwards;
        }

        @keyframes stampPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.02); }
            100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
        }

        /* Symbolic glyphs - ambient emergence */
        .ritual-glyphs {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .ritual-glyph {
            position: absolute;
            font-family: var(--font-mono);
            font-size: 18px;
            color: var(--gold-dim);
            opacity: 0;
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .ritual-glyph.visible {
            opacity: 0.6;
        }

        /* Calibration lines - only during convergence */
        .calibration-lines {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .calibration-lines.active {
            opacity: 1;
        }

        .calibration-line {
            position: absolute;
            background: var(--gold-dim);
            opacity: 0.3;
        }

        .calibration-line.horizontal {
            height: 1px;
            width: 100%;
            left: 0;
        }

        .calibration-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }

        /* ═══════════════════════════════════════
           SOVEREIGN HEADLINE
        ═══════════════════════════════════════ */
        .sovereign-headline {
            font-family: var(--font-display);
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: var(--weight-light);
            letter-spacing: -0.02em;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 1rem;
            opacity: 0;
            animation: fadeUp 1s var(--ease-out-expo) 0.5s forwards;
        }

        .sovereign-headline em {
            font-style: normal;
            color: var(--gold);
        }

        .sovereign-subline {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            text-align: center;
            text-transform: uppercase;
            max-width: 600px;
            margin: 0 auto 2rem;
            opacity: 0;
            animation: fadeUp 1s var(--ease-out-expo) 0.8s forwards;
        }

        /* ═══════════════════════════════════════
           RITUAL CTA - Appears only at end
        ═══════════════════════════════════════ */
        .ritual-cta-container {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-top: 2rem;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s var(--ease-out-expo);
            pointer-events: none;
        }

        .ritual-cta-container.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .ritual-cta {
            padding: 14px 32px;
            font-family: var(--font-mono);
            font-size: 12px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            border: 1px solid var(--gold-dim);
            background: transparent;
            color: var(--gold-white);
            cursor: pointer;
            transition: all 0.3s var(--ease-out);
        }

        .ritual-cta:hover {
            border-color: var(--gold);
            background: rgba(212, 175, 55, 0.1);
            box-shadow: 0 0 30px var(--glow-soft);
        }

        .ritual-cta.primary {
            background: var(--gold);
            border-color: var(--gold);
            color: var(--void);
            font-weight: var(--weight-medium);
        }

        .ritual-cta.primary:hover {
            background: var(--gold-bright);
            box-shadow: 0 0 40px var(--glow);
        }

        .ritual-cta.secondary {
            background: transparent;
            border-color: var(--gold-shadow);
            color: var(--gold-muted);
            font-size: 10px;
            padding: 10px 20px;
        }

        .ritual-cta.secondary:hover {
            border-color: var(--gold-dim);
            color: var(--gold);
        }

        /* ═══════════════════════════════════════
           REDUCED MOTION - Still scene
           Show final composition + CTA immediately
        ═══════════════════════════════════════ */
        @media (prefers-reduced-motion: reduce) {
            .ritual-stage {
                opacity: 1;
            }

            .ritual-phase-indicator,
            .ritual-message,
            .ritual-stamp,
            .ritual-glyph,
            .calibration-lines {
                display: none;
            }

            .ritual-cta-container {
                opacity: 1;
                transform: translateY(0);
                pointer-events: auto;
            }

            .sovereign-headline,
            .sovereign-subline {
                opacity: 1;
                animation: none;
            }
        }

        /* Hide legacy trust strip reference */
        .trust-strip {
            display: none !important;
        }

        .trust-strip-inner {
            max-width: var(--content-width);
            margin: 0 auto;
            padding: 0 var(--gutter);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 32px;
            flex-wrap: wrap;
        }

        .trust-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: var(--font-mono);
            font-size: 11px;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .trust-item .trust-icon {
            width: 14px;
            height: 14px;
            opacity: 0.7;
        }

        .trust-item.verified {
            color: var(--accent-success);
        }

        .trust-item.verified .trust-icon {
            opacity: 1;
        }

        .trust-badge {
            padding: 4px 10px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-family: var(--font-mono);
            font-size: 10px;
            letter-spacing: 0.08em;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════
           INSTRUMENTATION GRID OVERLAY
           Defense-tech visual language
        ═══════════════════════════════════════ */
        .instrumentation-grid {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 1;
            opacity: 0.15;
            overflow: hidden;
        }

        .grid-lines {
            position: absolute;
            inset: 0;
            background-image:
                linear-gradient(to right, var(--border-subtle) 1px, transparent 1px),
                linear-gradient(to bottom, var(--border-subtle) 1px, transparent 1px);
            background-size: 64px 64px;
            mask-image: radial-gradient(ellipse 60% 50% at 50% 50%, black 20%, transparent 70%);
        }

        /* Corner brackets - instrumentation aesthetic */
        .corner-bracket {
            position: fixed;
            width: 40px;
            height: 40px;
            z-index: 2;
            opacity: 0.3;
        }

        .corner-bracket::before,
        .corner-bracket::after {
            content: '';
            position: absolute;
            background: var(--gold-dim);
        }

        .corner-bracket.top-left {
            top: 80px;
            left: 24px;
        }
        .corner-bracket.top-left::before {
            top: 0; left: 0; width: 20px; height: 1px;
        }
        .corner-bracket.top-left::after {
            top: 0; left: 0; width: 1px; height: 20px;
        }

        .corner-bracket.top-right {
            top: 80px;
            right: 24px;
        }
        .corner-bracket.top-right::before {
            top: 0; right: 0; width: 20px; height: 1px;
        }
        .corner-bracket.top-right::after {
            top: 0; right: 0; width: 1px; height: 20px;
        }

        .corner-bracket.bottom-left {
            bottom: 24px;
            left: 24px;
        }
        .corner-bracket.bottom-left::before {
            bottom: 0; left: 0; width: 20px; height: 1px;
        }
        .corner-bracket.bottom-left::after {
            bottom: 0; left: 0; width: 1px; height: 20px;
        }

        .corner-bracket.bottom-right {
            bottom: 24px;
            right: 24px;
        }
        .corner-bracket.bottom-right::before {
            bottom: 0; right: 0; width: 20px; height: 1px;
        }
        .corner-bracket.bottom-right::after {
            bottom: 0; right: 0; width: 1px; height: 20px;
        }

        /* Technical annotations */
        .tech-annotation {
            position: fixed;
            font-family: var(--font-mono);
            font-size: 9px;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            opacity: 0.4;
            text-transform: uppercase;
            z-index: 2;
        }

        .tech-annotation.bottom-left {
            bottom: 32px;
            left: 70px;
        }

        .tech-annotation.bottom-right {
            bottom: 32px;
            right: 70px;
        }

        /* ═══════════════════════════════════════
           EXECUTIVE HERO - Outcome-focused
        ═══════════════════════════════════════ */
        .hero-outcome-headline {
            font-family: var(--font-display);
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: var(--weight-semibold);
            line-height: 1.1;
            letter-spacing: -0.02em;
            color: var(--text-primary);
            margin-bottom: 1rem;
            text-align: center;
            opacity: 0;
            animation: fadeUp 0.8s var(--ease-out-expo) 0.8s forwards;
        }

        .hero-outcome-headline .highlight {
            color: var(--gold);
            position: relative;
        }

        .hero-technical-subheadline {
            font-family: var(--font-body);
            font-size: clamp(1rem, 2vw, 1.25rem);
            font-weight: var(--weight-normal);
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto 2rem;
            text-align: center;
            line-height: 1.6;
            opacity: 0;
            animation: fadeUp 0.8s var(--ease-out-expo) 1s forwards;
        }

        /* Dual CTA pattern */
        .hero-cta-group {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeUp 0.8s var(--ease-out-expo) 1.2s forwards;
        }

        .cta-primary {
            padding: 14px 28px;
            background: var(--gold);
            color: var(--bg-primary);
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: var(--weight-semibold);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cta-primary:hover {
            background: var(--gold-bright);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(201, 162, 39, 0.3);
        }

        .cta-secondary {
            padding: 14px 28px;
            background: transparent;
            color: var(--text-primary);
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: var(--weight-medium);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cta-secondary:hover {
            border-color: var(--gold-dim);
            background: var(--bg-elevated);
        }

        /* ═══════════════════════════════════════
           TEAM CREDENTIALS SECTION
           Trust signals for pre-revenue companies
        ═══════════════════════════════════════ */
        .team-credentials {
            padding: 80px 0;
            background: var(--bg-elevated);
            border-top: 1px solid var(--border-subtle);
            border-bottom: 1px solid var(--border-subtle);
        }

        .credentials-header {
            text-align: center;
            margin-bottom: 48px;
        }

        .credentials-label {
            font-family: var(--font-mono);
            font-size: 11px;
            letter-spacing: 0.15em;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 12px;
        }

        .credentials-title {
            font-family: var(--font-display);
            font-size: clamp(1.5rem, 3vw, 2rem);
            font-weight: var(--weight-semibold);
            color: var(--text-primary);
        }

        .team-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            max-width: var(--content-width);
            margin: 0 auto;
            padding: 0 var(--gutter);
        }

        .team-member {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 24px;
            transition: all var(--duration-normal) var(--ease-out);
        }

        .team-member:hover {
            border-color: var(--gold-dim);
            transform: translateY(-4px);
        }

        .member-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .member-avatar {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--bg-surface);
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 20px;
            font-weight: var(--weight-semibold);
            color: var(--gold);
        }

        .member-info h4 {
            font-family: var(--font-display);
            font-size: 1.1rem;
            font-weight: var(--weight-semibold);
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .member-info .role {
            font-family: var(--font-mono);
            font-size: 11px;
            letter-spacing: 0.08em;
            color: var(--gold);
            text-transform: uppercase;
        }

        .member-credentials {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .member-links {
            display: flex;
            gap: 12px;
        }

        .member-link {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--text-muted);
            padding: 6px 12px;
            background: var(--bg-elevated);
            border-radius: var(--radius-sm);
            transition: all var(--duration-fast) var(--ease-out);
        }

        .member-link:hover {
            color: var(--gold);
            background: var(--bg-surface);
        }

        /* ═══════════════════════════════════════
           METRICS STRIP - Social proof for early-stage
        ═══════════════════════════════════════ */
        .metrics-strip {
            display: flex;
            justify-content: center;
            gap: 48px;
            padding: 32px 0;
            flex-wrap: wrap;
            opacity: 0;
            animation: fadeUp 0.8s var(--ease-out-expo) 1.4s forwards;
        }

        .metric-item {
            text-align: center;
        }

        .metric-value {
            font-family: var(--font-display);
            font-size: 2rem;
            font-weight: var(--weight-bold);
            color: var(--gold);
            line-height: 1;
            margin-bottom: 4px;
        }

        .metric-label {
            font-family: var(--font-mono);
            font-size: 10px;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════
           NAVIGATION - Enterprise path
        ═══════════════════════════════════════ */
        .nav-persona-switch {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: var(--bg-elevated);
            border-radius: var(--radius-md);
            margin-right: 24px;
        }

        .persona-btn {
            padding: 8px 16px;
            font-family: var(--font-mono);
            font-size: 11px;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }

        .persona-btn.active {
            background: var(--bg-surface);
            color: var(--text-primary);
        }

        .persona-btn:hover:not(.active) {
            color: var(--text-primary);
        }

        /* ═══════════════════════════════════════
           PASSIVE DEMO INDICATOR
        ═══════════════════════════════════════ */
        .passive-demo-indicator {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: var(--font-mono);
            font-size: 10px;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            text-transform: uppercase;
            opacity: 0;
            animation: fadeIn 0.6s var(--ease-out) 3s forwards;
        }

        .demo-pulse {
            width: 6px;
            height: 6px;
            background: var(--accent-success);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        /* Mobile adjustments for executive elements */
        @media (max-width: 768px) {
            .trust-strip-inner {
                gap: 16px;
                font-size: 10px;
            }

            .trust-item {
                font-size: 10px;
            }

            .corner-bracket {
                display: none;
            }

            .hero-cta-group {
                flex-direction: column;
                align-items: center;
            }

            .cta-primary, .cta-secondary {
                width: 100%;
                max-width: 280px;
                justify-content: center;
            }

            .metrics-strip {
                gap: 24px;
            }

            .nav-persona-switch {
                display: none;
            }
        }

        /* ═══════════════════════════════════════
           TRUST INSPECTOR - Prove Zero Egress
           One-click verification of claims
        ═══════════════════════════════════════ */
        .trust-inspector {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 1000;
        }

        .trust-inspector-toggle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--duration-fast) var(--ease-out);
        }

        .trust-inspector-toggle:hover {
            border-color: var(--gold-dim);
            color: var(--gold);
        }

        .trust-inspector-toggle.verified {
            border-color: var(--semantic-verified);
            color: var(--semantic-verified);
            box-shadow: 0 0 20px var(--semantic-verified-glow);
        }

        .trust-inspector-panel {
            position: absolute;
            bottom: 56px;
            right: 0;
            width: 320px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 16px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all var(--duration-normal) var(--ease-out);
        }

        .trust-inspector-panel.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .inspector-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .inspector-title {
            font-family: var(--font-mono);
            font-size: 11px;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .inspector-status {
            font-family: var(--font-mono);
            font-size: 10px;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            background: var(--semantic-verified-glow);
            color: var(--semantic-verified);
        }

        .inspector-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .inspector-row:last-child {
            border-bottom: none;
        }

        .inspector-label {
            font-family: var(--font-mono);
            font-size: 10px;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .inspector-value {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--text-primary);
        }

        .inspector-value.success {
            color: var(--semantic-verified);
        }

        .inspector-hash {
            font-size: 9px;
            color: var(--text-muted);
            word-break: break-all;
            margin-top: 4px;
        }

        /* ═══════════════════════════════════════
           VERIFIED MOMENT - Signature Ritual
           Unmistakable "this is real" event
        ═══════════════════════════════════════ */
        .trust-strip.verified {
            border-color: var(--semantic-verified);
            background: linear-gradient(180deg,
                rgba(34, 197, 94, 0.1) 0%,
                var(--bg-primary) 100%);
        }

        .trust-strip.verified .trust-item.verified {
            color: var(--semantic-verified);
            text-shadow: 0 0 10px var(--semantic-verified-glow);
        }

        /* Receipt stamp animation */
        .receipt-stamp {
            position: absolute;
            top: -20px;
            right: -20px;
            width: 80px;
            height: 80px;
            opacity: 0;
            transform: scale(0) rotate(-15deg);
            transition: all 0.5s var(--ease-spring);
            pointer-events: none;
        }

        .receipt-stamp.stamped {
            opacity: 1;
            transform: scale(1) rotate(-15deg);
        }

        .receipt-stamp svg {
            width: 100%;
            height: 100%;
        }

        /* Crown seal motion */
        .crown-logo.sealing .verification-mark {
            animation: sealStamp 0.6s var(--ease-spring) forwards;
        }

        @keyframes sealStamp {
            0% { transform: scale(0) translateY(-10px); opacity: 0; }
            50% { transform: scale(1.3) translateY(0); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 0.9; }
        }

        /* Crystal lock state */
        .witness-crystal.inspectable .crystal-facet {
            cursor: pointer;
            transition: all var(--duration-fast) var(--ease-out);
        }

        .witness-crystal.inspectable .crystal-facet:hover {
            border-color: var(--gold);
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--glow);
        }

        /* Demo seed display */
        .demo-seed-display {
            font-family: var(--font-mono);
            font-size: 9px;
            color: var(--text-muted);
            margin-top: 8px;
            opacity: 0.6;
        }

        .demo-seed-display code {
            background: var(--bg-elevated);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            color: var(--gold-dim);
        }

        /* Exec mode - reduced instrumentation grid */
        [data-mode="exec"] .instrumentation-grid {
            opacity: 0.08;
        }

        [data-mode="exec"] .corner-bracket {
            opacity: 0.15;
        }

        @media (max-width: 768px) {
            .trust-inspector {
                bottom: 16px;
                right: 16px;
            }

            .trust-inspector-panel {
                width: 280px;
                right: -8px;
            }
        }

        /* ════════════════════════════════════════════════════════════════
           PARADIGM SHIFT: THE PROOF BECOMES THE INTERFACE
           Every visual effect is now a projection of proof state
        ════════════════════════════════════════════════════════════════ */

        /* ═══════════════════════════════════════
           PROOF INTERFACE - The Command Center
        ═══════════════════════════════════════ */
        .proof-interface {
            position: relative;
            z-index: 100;
            width: 100%;
            max-width: 680px;
            margin: 0 auto 2rem;
            opacity: 0;
            animation: fadeUp 0.9s var(--ease-out-expo) 2.6s forwards;
        }

        .proof-input-container {
            background: linear-gradient(135deg, rgba(10, 10, 15, 0.95) 0%, rgba(5, 5, 8, 0.98) 100%);
            border: 1px solid var(--gold-shadow);
            border-radius: 12px;
            padding: 1.5rem;
            backdrop-filter: blur(12px);
            position: relative;
            overflow: hidden;
            transition: all 0.5s var(--ease-out-expo);
        }

        .proof-input-container::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at 50% 0%, rgba(212, 175, 55, 0.08) 0%, transparent 60%);
            pointer-events: none;
        }

        .proof-input-container:focus-within {
            border-color: var(--gold-dim);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.15), 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .proof-input-container[data-phase="search"] {
            border-color: var(--gold-dim);
            animation: searchPulse 1.5s ease-in-out infinite;
        }

        .proof-input-container[data-phase="crystallize"] {
            border-color: var(--gold-core);
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.3);
        }

        @keyframes searchPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.1); }
            50% { box-shadow: 0 0 40px rgba(212, 175, 55, 0.25); }
        }

        .proof-label {
            font-family: var(--font-mono);
            font-size: 0.58rem;
            letter-spacing: 0.3em;
            color: var(--gold-dim);
            margin-bottom: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .proof-label::before {
            content: '⊢';
            font-size: 0.9rem;
            color: var(--gold-core);
        }

        .claim-input {
            width: 100%;
            padding: 1rem 1.2rem;
            background: rgba(212, 175, 55, 0.03);
            border: 1px solid var(--gold-shadow);
            border-radius: 8px;
            color: var(--gold-white);
            font-family: var(--font-mono);
            font-size: 1.1rem;
            letter-spacing: 0.05em;
            outline: none;
            transition: all 0.3s ease;
        }

        .claim-input::placeholder {
            color: var(--gold-dim);
            font-style: italic;
        }

        .claim-input:focus {
            border-color: var(--gold-core);
            background: rgba(212, 175, 55, 0.05);
            box-shadow: inset 0 0 20px rgba(212, 175, 55, 0.05);
        }

        .proof-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .preset-btn {
            padding: 0.45rem 0.9rem;
            background: transparent;
            border: 1px solid var(--gold-darkest);
            border-radius: 6px;
            color: var(--gold-muted);
            font-family: var(--font-mono);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.3s var(--ease-out-expo);
            position: relative;
            overflow: hidden;
        }

        .preset-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--gold-core);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s var(--ease-out-expo);
            z-index: -1;
        }

        .preset-btn:hover {
            border-color: var(--gold-dim);
            color: var(--gold-white);
        }

        .preset-btn:hover::before {
            transform: scaleX(1);
        }

        .preset-btn:hover {
            color: var(--void);
        }

        .proof-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .prove-btn, .replay-btn {
            flex: 1;
            padding: 0.9rem 1.5rem;
            border: 1px solid var(--gold-dim);
            background: transparent;
            font-family: var(--font-mono);
            font-size: 0.72rem;
            letter-spacing: 0.2em;
            color: var(--gold-white);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s var(--ease-out-expo);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.6rem;
        }

        .prove-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--gold-core), var(--gold-bright));
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.5s var(--ease-out-expo);
            z-index: -1;
        }

        .prove-btn:hover:not(:disabled) {
            color: var(--void);
            border-color: var(--gold-core);
            box-shadow: 0 0 30px var(--glow-soft);
        }

        .prove-btn:hover:not(:disabled)::before {
            transform: scaleX(1);
        }

        .prove-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .prove-btn[data-proving="true"] {
            background: var(--gold-shadow);
            color: var(--gold-bright);
        }

        .replay-btn {
            border-color: var(--gold-shadow);
            opacity: 0.4;
            pointer-events: none;
        }

        .replay-btn.available {
            opacity: 1;
            pointer-events: auto;
        }

        .replay-btn.available:hover {
            border-color: var(--gold-dim);
            background: rgba(212, 175, 55, 0.1);
        }

        .btn-icon {
            font-size: 1rem;
            transition: transform 0.3s ease;
        }

        .prove-btn:hover .btn-icon {
            transform: rotate(45deg);
        }

        /* ═══════════════════════════════════════
           WITNESS CRYSTAL - 3D Verification Object
        ═══════════════════════════════════════ */
        .witness-crystal-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            pointer-events: none;
            z-index: 8;
            opacity: 0;
            transition: opacity 0.8s var(--ease-out-expo);
        }

        .witness-crystal-container.active {
            opacity: 1;
        }

        .witness-crystal {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            animation: crystalFloat 8s ease-in-out infinite;
        }

        @keyframes crystalFloat {
            0%, 100% { transform: rotateX(5deg) rotateY(0deg) translateY(0); }
            50% { transform: rotateX(8deg) rotateY(180deg) translateY(-10px); }
        }

        .witness-crystal.locked {
            animation: none;
            transform: rotateX(5deg) rotateY(var(--crystal-rotation, 0deg));
        }

        .crystal-facet {
            position: absolute;
            border: 1px solid var(--gold-dim);
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.05) 0%, rgba(212, 175, 55, 0.02) 100%);
            transform-style: preserve-3d;
            backface-visibility: visible;
            opacity: 0;
            transition: all 0.6s var(--ease-out-expo);
        }

        .crystal-facet.visible {
            opacity: 1;
        }

        .crystal-facet.verified {
            border-color: var(--gold-core);
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.15) 0%, rgba(212, 175, 55, 0.05) 100%);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }

        .crystal-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, var(--gold-core) 0%, transparent 70%);
            border-radius: 50%;
            opacity: 0;
            filter: blur(10px);
            transition: all 0.8s var(--ease-out-expo);
        }

        .crystal-core.active {
            opacity: 0.6;
            filter: blur(15px);
            animation: coreGlow 2s ease-in-out infinite;
        }

        @keyframes coreGlow {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.6; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
        }

        .crystal-core.verified {
            opacity: 1;
            filter: blur(8px);
            animation: none;
            box-shadow: 0 0 40px var(--gold-core);
        }

        /* ═══════════════════════════════════════
           PROOF RECEIPT - Verification Artifact
        ═══════════════════════════════════════ */
        .proof-receipt {
            position: relative;
            z-index: 100;
            max-width: 680px;
            margin: 1.5rem auto 0;
            background: linear-gradient(135deg, rgba(10, 10, 15, 0.95) 0%, rgba(5, 5, 8, 0.98) 100%);
            border: 1px solid var(--gold-shadow);
            border-radius: 12px;
            padding: 1.25rem 1.5rem;
            backdrop-filter: blur(12px);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s var(--ease-out-expo);
            pointer-events: none;
        }

        .proof-receipt.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .receipt-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--gold-darkest);
        }

        .receipt-title {
            font-family: var(--font-mono);
            font-size: 0.62rem;
            letter-spacing: 0.25em;
            color: var(--gold-dim);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .receipt-title::before {
            content: '∎';
            color: var(--gold-core);
            animation: qedPulse 2s ease-in-out infinite;
        }

        @keyframes qedPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; text-shadow: 0 0 10px var(--gold-core); }
        }

        .receipt-status {
            font-family: var(--font-mono);
            font-size: 0.58rem;
            letter-spacing: 0.15em;
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            background: rgba(212, 175, 55, 0.15);
            color: var(--gold-bright);
            border: 1px solid var(--gold-dim);
        }

        .receipt-body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .receipt-field {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .receipt-field.full {
            grid-column: 1 / -1;
        }

        .field-label {
            font-family: var(--font-mono);
            font-size: 0.52rem;
            letter-spacing: 0.2em;
            color: var(--gold-dim);
        }

        .field-value {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--gold-white);
            padding: 0.5rem 0.7rem;
            background: rgba(212, 175, 55, 0.03);
            border: 1px solid var(--gold-darkest);
            border-radius: 4px;
            word-break: break-all;
        }

        .field-value.hash {
            font-size: 0.6rem;
            letter-spacing: 0.05em;
            color: var(--gold-muted);
        }

        .receipt-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--gold-darkest);
        }

        .receipt-btn {
            flex: 1;
            padding: 0.6rem 1rem;
            background: transparent;
            border: 1px solid var(--gold-shadow);
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 0.6rem;
            letter-spacing: 0.15em;
            color: var(--gold-muted);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .receipt-btn:hover {
            border-color: var(--gold-dim);
            color: var(--gold-white);
            background: rgba(212, 175, 55, 0.05);
        }

        /* ═══════════════════════════════════════
           SEMANTIC LENS CURSOR ENHANCEMENTS
        ═══════════════════════════════════════ */
        .cursor-lens-info {
            position: fixed;
            pointer-events: none;
            z-index: 10002;
            background: rgba(5, 5, 8, 0.95);
            border: 1px solid var(--gold-dim);
            border-radius: 8px;
            padding: 0.6rem 0.9rem;
            font-family: var(--font-mono);
            font-size: 0.6rem;
            color: var(--gold-white);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s var(--ease-out-expo);
            max-width: 250px;
            backdrop-filter: blur(8px);
        }

        .cursor-lens-info.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .lens-rule {
            color: var(--gold-core);
            font-weight: 500;
        }

        .lens-step {
            color: var(--gold-muted);
            font-size: 0.55rem;
            margin-top: 0.3rem;
        }

        /* ═══════════════════════════════════════
           CAUSAL TRACE PARTICLES
        ═══════════════════════════════════════ */
        .causal-trace {
            position: absolute;
            width: 3px;
            height: 3px;
            background: var(--gold-core);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 8px var(--gold-core), 0 0 16px rgba(212, 175, 55, 0.4);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .causal-trace.active {
            opacity: 1;
        }

        .causal-trace.diverging {
            animation: traceDiverge 2s ease-out forwards;
        }

        .causal-trace.converging {
            animation: traceConverge 1.5s ease-in-out forwards;
        }

        @keyframes traceDiverge {
            0% { opacity: 1; transform: translate(0, 0) scale(1); }
            100% { opacity: 0; transform: translate(var(--trace-dx, 50px), var(--trace-dy, 50px)) scale(0.3); }
        }

        @keyframes traceConverge {
            0% { opacity: 0.8; }
            100% { opacity: 0; transform: translate(var(--target-x, 0), var(--target-y, 0)) scale(0.5); }
        }

        /* ═══════════════════════════════════════
           PROOF-DRIVEN ANIMATION STATES
        ═══════════════════════════════════════ */

        /* Phase: IDLE */
        [data-proof-phase="idle"] .consciousness-shader {
            opacity: 0.25;
        }

        [data-proof-phase="idle"] .sacred-geometry {
            opacity: 0.04;
        }

        /* Phase: SEARCH */
        [data-proof-phase="search"] .consciousness-shader {
            opacity: 0.45;
            filter: saturate(1.2);
        }

        [data-proof-phase="search"] .sacred-geometry {
            opacity: 0.08;
            animation: geoRotate 60s linear infinite;
        }

        [data-proof-phase="search"] .energy-rings .energy-ring {
            animation-duration: 3s;
        }

        /* Phase: CONVERGE */
        [data-proof-phase="converge"] .consciousness-shader {
            opacity: 0.5;
        }

        [data-proof-phase="converge"] .sacred-geometry {
            opacity: 0.1;
            animation: geoRotate 30s linear infinite;
        }

        /* Phase: CRYSTALLIZE */
        [data-proof-phase="crystallize"] .consciousness-shader {
            opacity: 0.6;
            filter: saturate(1.4) brightness(1.1);
        }

        [data-proof-phase="crystallize"] .sacred-geometry {
            opacity: 0.15;
            animation: none;
            transform: translate(-50%, -50%) rotate(var(--proof-rotation, 0deg));
        }

        [data-proof-phase="crystallize"] .energy-rings .energy-ring {
            animation: none;
            opacity: 0;
        }

        /* Verification Flash */
        .verification-flash {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at 50% 50%, rgba(212, 175, 55, 0.2) 0%, transparent 60%);
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .verification-flash.active {
            animation: verifyFlash 1s ease-out forwards;
        }

        @keyframes verifyFlash {
            0% { opacity: 0; transform: scale(0.8); }
            20% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(1.5); }
        }

        /* ═══════════════════════════════════════
           VIEW TRANSITIONS FOR STATE MORPHING
        ═══════════════════════════════════════ */
        @view-transition {
            navigation: auto;
        }

        ::view-transition-old(proof-state),
        ::view-transition-new(proof-state) {
            animation-duration: 0.5s;
            animation-timing-function: var(--ease-out-expo);
        }

        .proof-input-container {
            view-transition-name: proof-state;
        }

        /* ═══════════════════════════════════════
           RESPONSIVE ADJUSTMENTS
        ═══════════════════════════════════════ */
        @media (max-width: 768px) {
            .proof-interface {
                padding: 0 1rem;
            }

            .proof-input-container {
                padding: 1rem;
            }

            .claim-input {
                font-size: 0.9rem;
            }

            .proof-presets {
                justify-content: center;
            }

            .receipt-body {
                grid-template-columns: 1fr;
            }

            .witness-crystal-container {
                width: 280px;
                height: 280px;
            }
        }
    </style>

    <!-- Zero external dependencies - Pure WebGL sovereignty -->
</head>
<body data-proof-phase="idle">

    <!-- ════════════════════════════════════════════════════════════════
         EXECUTIVE-GRADE TRUST INFRASTRUCTURE
         Pre-hero signals for 3-5 second credibility window
    ════════════════════════════════════════════════════════════════ -->

    <!-- Trust Strip - Above the fold -->
    <div class="trust-strip" id="trustStrip">
        <div class="trust-strip-inner">
            <div class="trust-item verified">
                <svg class="trust-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                    <path d="M9 12l2 2 4-4"/>
                </svg>
                <span>Deterministic Proofs</span>
            </div>
            <div class="trust-item">
                <svg class="trust-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                </svg>
                <span>Zero Egress</span>
            </div>
            <div class="trust-item">
                <svg class="trust-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 6v6l4 2"/>
                </svg>
                <span>Minutes, Not Months</span>
            </div>
            <span class="trust-badge">Open Source</span>
        </div>
    </div>

    <!-- Instrumentation Grid - Defense-tech aesthetic -->
    <div class="instrumentation-grid">
        <div class="grid-lines"></div>
    </div>

    <!-- Corner Brackets - Precision calibration marks -->
    <div class="corner-bracket top-left"></div>
    <div class="corner-bracket top-right"></div>
    <div class="corner-bracket bottom-left"></div>
    <div class="corner-bracket bottom-right"></div>

    <!-- Technical Annotations -->
    <div class="tech-annotation bottom-left">SYS.NEURAL.THEOREM.v1</div>
    <div class="tech-annotation bottom-right">SOVEREIGN.VERIFICATION</div>

    <!-- Trust Inspector - Prove Zero Egress claims -->
    <div class="trust-inspector" id="trustInspector">
        <button class="trust-inspector-toggle" id="trustInspectorToggle" aria-label="Open trust inspector">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                <path d="M9 12l2 2 4-4"/>
            </svg>
        </button>
        <div class="trust-inspector-panel" id="trustInspectorPanel">
            <div class="inspector-header">
                <span class="inspector-title">Trust Inspector</span>
                <span class="inspector-status" id="inspectorStatus">VERIFIED</span>
            </div>
            <div class="inspector-row">
                <span class="inspector-label">Network Requests</span>
                <span class="inspector-value success" id="networkCount">0</span>
            </div>
            <div class="inspector-row">
                <span class="inspector-label">External Origins</span>
                <span class="inspector-value success" id="externalOrigins">None</span>
            </div>
            <div class="inspector-row">
                <span class="inspector-label">Demo Seed</span>
                <span class="inspector-value" id="demoSeedDisplay">—</span>
            </div>
            <div class="inspector-row">
                <span class="inspector-label">Session</span>
                <span class="inspector-value" id="sessionId">—</span>
            </div>
            <div class="inspector-row" style="flex-direction: column; align-items: flex-start;">
                <span class="inspector-label">Receipt Hash</span>
                <span class="inspector-hash" id="inspectorReceiptHash">No proof yet</span>
            </div>
        </div>
    </div>

    <!-- Verification Flash Overlay -->
    <div class="verification-flash" id="verificationFlash"></div>

    <!-- Semantic Lens Cursor Info -->
    <div class="cursor-lens-info" id="cursorLensInfo">
        <div class="lens-rule"></div>
        <div class="lens-step"></div>
    </div>

    <!-- Loading Screen with DNA Helix -->
    <div class="loading-screen" id="loadingScreen">
        <div class="dna-helix">
            <div class="dna-strand" id="dnaStrand"></div>
        </div>
        <div class="loading-text">INITIALIZING PROOF KERNEL</div>
    </div>

    <!-- ════════════════════════════════════════════════════════════════
         VISUAL OVERLAYS - Simplified for executive clarity
         Jamming effects hidden. Instrumentation grid remains.
         Re-enable with data-mode="creative" on body
    ════════════════════════════════════════════════════════════════ -->

    <!-- Minimal overlays - subtle grain only -->
    <div class="overlay-grain" style="opacity: 0.03;"></div>

    <!-- Hidden: These compete with executive credibility
         Uncomment for creative/developer mode -->
    <!--
    <div class="overlay-scanlines"></div>
    <div class="noise-overlay"></div>
    <div class="morphic-field" id="morphicField">...</div>
    <svg class="quantum-threads" id="quantumThreads">...</svg>
    <div class="depth-fog" id="depthFog">...</div>
    <div class="data-stream-container" id="dataStreamContainer"></div>
    -->

    <!-- Consciousness Particles - kept for causal trace system -->
    <div class="consciousness-particles" id="consciousnessParticles"></div>

    <!-- Cursor -->
    <div class="cursor-core" id="cursorCore"></div>
    <div class="cursor-aura" id="cursorAura"></div>

    <!-- Awakening Meter -->
    <div class="awakening-meter" id="awakeningMeter">
        <div class="awakening-node" data-section="hero"></div>
        <div class="awakening-track">
            <div class="awakening-fill" id="awakeningFill"></div>
        </div>
        <div class="awakening-node" data-section="foundation"></div>
        <div class="awakening-node" data-section="intelligence"></div>
        <div class="awakening-node" data-section="sovereignty"></div>
        <div class="awakening-node" data-section="nexus"></div>
        <div class="awakening-label">CONSCIOUSNESS</div>
    </div>

    <!-- Navigation -->
    <nav id="nav">
        <div class="nav-container">
            <a href="#" class="nav-brand">
                <svg class="nav-brand-icon" viewBox="0 0 32 38" fill="none">
                    <polygon points="16,2 22,12 10,12" fill="#D4AF37"/>
                    <polygon points="6,7 11,15 1,15" fill="#B8942A"/>
                    <polygon points="26,7 31,15 21,15" fill="#B8942A"/>
                    <path d="M 0 17 Q 16 24 32 17" stroke="#D4AF37" stroke-width="1.5" fill="none"/>
                    <text x="16" y="31" fill="#D4AF37" font-family="serif" font-size="18" font-style="italic" text-anchor="middle" dominant-baseline="middle">λ</text>
                </svg>
                <span class="nav-brand-text">CYTHERAI</span>
            </a>
            <ul class="nav-links">
                <li><a href="#foundation">FOUNDATION</a></li>
                <li><a href="#intelligence">INTELLIGENCE</a></li>
                <li><a href="#sovereignty">SOVEREIGNTY</a></li>
                <li><a href="#nexus">NEXUS</a></li>
            </ul>
        </div>
    </nav>

    <main>
        <!-- HERO -->
        <section class="hero" id="hero">
            <!-- Architectural Light System - Sharp geometry, not diffuse glow -->
            <div class="light-architecture">
                <div class="light-pillar"></div>
                <div class="light-pillar"></div>
                <div class="light-pillar"></div>
            </div>
            <div class="horizon-line"></div>

            <!-- Consciousness Shader -->
            <canvas class="consciousness-shader" id="consciousnessShader"></canvas>

            <!-- Three.js 3D Field -->
            <div class="consciousness-3d" id="consciousness3D"></div>

            <!-- Hidden: Decorative overlays that compete with executive clarity
                 Re-enable with data-mode="creative" on body -->
            <!-- Golden Spiral, Energy Rings, Hex Grid - hidden for exec mode -->
            <div class="golden-spiral" style="display:none;"></div>
            <div class="energy-rings" style="display:none;"></div>
            <div class="hex-grid" style="display:none;"></div>

            <!-- Sacred Geometry -->
            <div class="sacred-geometry">
                <div class="geometry-layer">
                    <svg viewBox="0 0 200 200" fill="none" stroke="currentColor" stroke-width="0.4" opacity="0.5">
                        <circle cx="100" cy="100" r="90" stroke="var(--gold-dim)"/>
                        <circle cx="100" cy="100" r="70" stroke="var(--gold-dim)"/>
                        <circle cx="100" cy="100" r="50" stroke="var(--gold-dim)"/>
                        <polygon points="100,10 190,100 100,190 10,100" stroke="var(--gold-dim)" fill="none"/>
                    </svg>
                </div>
                <div class="geometry-layer">
                    <svg viewBox="0 0 200 200" fill="none" stroke="currentColor" stroke-width="0.3" opacity="0.4">
                        <polygon points="100,5 195,52 195,148 100,195 5,148 5,52" stroke="var(--gold-shadow)" fill="none"/>
                        <line x1="100" y1="5" x2="100" y2="195" stroke="var(--gold-shadow)"/>
                        <line x1="5" y1="52" x2="195" y2="148" stroke="var(--gold-shadow)"/>
                        <line x1="195" y1="52" x2="5" y2="148" stroke="var(--gold-shadow)"/>
                    </svg>
                </div>
                <div class="geometry-layer">
                    <svg viewBox="0 0 200 200" fill="none" stroke="currentColor" stroke-width="0.25" opacity="0.3">
                        <circle cx="100" cy="35" r="28" stroke="var(--gold-shadow)"/>
                        <circle cx="145" cy="75" r="28" stroke="var(--gold-shadow)"/>
                        <circle cx="145" cy="125" r="28" stroke="var(--gold-shadow)"/>
                        <circle cx="100" cy="165" r="28" stroke="var(--gold-shadow)"/>
                        <circle cx="55" cy="125" r="28" stroke="var(--gold-shadow)"/>
                        <circle cx="55" cy="75" r="28" stroke="var(--gold-shadow)"/>
                    </svg>
                </div>
            </div>

            <!-- Neural Field -->
            <div class="neural-field" id="neuralField"></div>

            <!-- Quantum Grid -->
            <div class="quantum-grid">
                <div class="grid-plane"></div>
                <div class="grid-plane"></div>
            </div>

            <!-- THE INTEGRATED CROWN LOGO -->
            <div class="logo-system">
                <div class="logo-container" id="logoContainer">
                    <div class="logo-glow"></div>
                    
                    <div class="logo-particles">
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                        <div class="particle"></div>
                    </div>

                    <svg class="integrated-crown" viewBox="0 0 200 240" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <!-- Crown Peaks -->
                        <polygon class="crown-peak-center" points="100,8 120,48 80,48" fill="#D4AF37"/>
                        <polygon class="crown-peak-left" points="46,30 64,62 28,62" fill="#B8942A"/>
                        <polygon class="crown-peak-right" points="154,30 172,62 136,62" fill="#B8942A"/>
                        
                        <!-- Crown Arc -->
                        <path class="crown-arc" d="M 20 70 Q 100 98 180 70" stroke="#D4AF37" stroke-width="3" fill="none" stroke-linecap="round"/>
                        
                        <!-- Crown Terminals -->
                        <circle class="crown-terminal-left" cx="20" cy="70" r="4" fill="#B8942A"/>
                        <circle class="crown-terminal-right" cx="180" cy="70" r="4" fill="#B8942A"/>
                        
                        <!-- Crown Jewels -->
                        <circle class="crown-jewel-center" cx="100" cy="22" r="5" fill="#F4D675"/>
                        <circle class="crown-jewel-left" cx="46" cy="42" r="3.5" fill="#E8C547"/>
                        <circle class="crown-jewel-right" cx="154" cy="42" r="3.5" fill="#E8C547"/>
                        
                        <!-- Lambda Symbol -->
                        <text class="lambda-symbol" x="100" y="158" fill="#D4AF37" font-family="'Cormorant Garamond', Georgia, serif" font-size="135" font-style="italic" font-weight="400" text-anchor="middle" dominant-baseline="middle">λ</text>
                        
                        <!-- Verification Mark -->
                        <path class="verification-mark" d="M 75 210 L 90 225 L 128 180" stroke="#6B5A2F" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round" opacity="0.4"/>
                    </svg>
                </div>

                <!-- Wordmark -->
                <div class="wordmark">
                    <div class="wordmark-text">CYTHERAI</div>
                    <div class="wordmark-tagline">NEURAL THEOREM PROVER</div>
                </div>
            </div>

            <!-- ════════════════════════════════════════
                 WITNESS CRYSTAL - 3D Verification Object
                 Emerges from proof completion
            ════════════════════════════════════════ -->
            <div class="witness-crystal-container" id="witnessCrystalContainer">
                <div class="witness-crystal" id="witnessCrystal">
                    <div class="crystal-core" id="crystalCore"></div>
                    <!-- Facets generated dynamically by proof state -->
                </div>
            </div>

            <!-- ════════════════════════════════════════
                 PROOF INTERFACE - The Command Center
                 Where users run verifiable proofs
            ════════════════════════════════════════ -->
            <div class="proof-interface" id="proofInterface">
                <div class="proof-input-container" id="proofInputContainer">
                    <label class="proof-label">ENTER CLAIM TO VERIFY</label>
                    <input
                        type="text"
                        class="claim-input"
                        id="claimInput"
                        placeholder="((P → Q) ∧ P) → Q"
                        spellcheck="false"
                        autocomplete="off"
                    >
                    <div class="proof-presets">
                        <button class="preset-btn" data-claim="((P → Q) ∧ P) → Q">Modus Ponens</button>
                        <button class="preset-btn" data-claim="(P ∧ Q) → P">∧-Elimination</button>
                        <button class="preset-btn" data-claim="P → (P ∨ Q)">∨-Introduction</button>
                        <button class="preset-btn" data-claim="(P → Q) → (¬Q → ¬P)">Contraposition</button>
                        <button class="preset-btn" data-claim="¬¬P → P">Double Negation</button>
                    </div>
                    <div class="proof-actions">
                        <button class="prove-btn" id="proveBtn">
                            <span>PROVE</span>
                            <span class="btn-icon">⊢</span>
                        </button>
                        <button class="replay-btn" id="replayBtn">
                            <span>REPLAY</span>
                            <span class="btn-icon">↺</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- ════════════════════════════════════════
                 PROOF RECEIPT - Verification Artifact
                 Cryptographic proof of verification
            ════════════════════════════════════════ -->
            <div class="proof-receipt" id="proofReceipt">
                <div class="receipt-header">
                    <span class="receipt-title">PROOF RECEIPT</span>
                    <span class="receipt-status">VERIFIED</span>
                </div>
                <div class="receipt-body">
                    <div class="receipt-field">
                        <span class="field-label">CLAIM</span>
                        <div class="field-value" id="receiptClaim">—</div>
                    </div>
                    <div class="receipt-field">
                        <span class="field-label">STEPS</span>
                        <div class="field-value" id="receiptSteps">—</div>
                    </div>
                    <div class="receipt-field">
                        <span class="field-label">RULES APPLIED</span>
                        <div class="field-value" id="receiptRules">—</div>
                    </div>
                    <div class="receipt-field">
                        <span class="field-label">TIMESTAMP</span>
                        <div class="field-value" id="receiptTimestamp">—</div>
                    </div>
                    <div class="receipt-field full">
                        <span class="field-label">WITNESS HASH (SHA-256)</span>
                        <div class="field-value hash" id="receiptHash">—</div>
                    </div>
                </div>
                <div class="receipt-actions">
                    <button class="receipt-btn" id="copyReceiptBtn">COPY HASH</button>
                    <button class="receipt-btn" id="downloadReceiptBtn">DOWNLOAD JSON</button>
                    <button class="receipt-btn" id="verifyReceiptBtn">VERIFY</button>
                </div>
            </div>

            <!-- ════════════════════════════════════════════════════════════════
                 REALITY TEASER - Cinematic one-pass experience
                 No forms. No receipts. Just the machine revealing itself.
            ════════════════════════════════════════════════════════════════ -->
            <div class="hero-content">
                <!-- Sovereign headline -->
                <h1 class="sovereign-headline">
                    Sovereign <em>Neural</em> Theorem Prover
                </h1>
                <p class="sovereign-subline">
                    Trained from random initialization. Fully reproducible. Zero dependencies.
                </p>

                <!-- Ritual Stage - Containment Chamber -->
                <div class="ritual-stage" id="ritualStage">
                    <!-- Phase indicator - transient micro-artifacts -->
                    <div class="ritual-phase-indicator" id="ritualPhase"></div>

                    <!-- Calibration lines - appear during convergence as calibration marks -->
                    <div class="calibration-lines" id="calibrationLines">
                        <div class="calibration-line horizontal" style="top: 25%;"></div>
                        <div class="calibration-line horizontal" style="top: 50%;"></div>
                        <div class="calibration-line horizontal" style="top: 75%;"></div>
                        <div class="calibration-line vertical" style="left: 25%;"></div>
                        <div class="calibration-line vertical" style="left: 50%;"></div>
                        <div class="calibration-line vertical" style="left: 75%;"></div>
                    </div>

                    <!-- Symbolic glyphs - ambient emergence (optional during convergence) -->
                    <div class="ritual-glyphs" id="ritualGlyphs">
                        <!-- Generated by RitualController -->
                    </div>

                    <!-- The crown and crystal render here via existing systems -->

                    <!-- Stamp line - single seal at Lock moment -->
                    <div class="ritual-stamp" id="ritualStamp"></div>

                    <!-- Ritual message - flashes at key moments -->
                    <div class="ritual-message" id="ritualMessage"></div>
                </div>

                <!-- CTA appears only at ritual end (ACT 4: Hold) -->
                <div class="ritual-cta-container" id="ritualCTA">
                    <a href="mailto:nda@cytherai.com?subject=NDA%20Briefing%20Request" class="ritual-cta primary">Request NDA Briefing</a>
                    <button class="ritual-cta secondary" id="replayRitual">Replay</button>
                </div>
            </div>

            <!-- Scroll Indicator -->
            <div class="scroll-indicator">
                <div class="scroll-track">
                    <div class="scroll-pulse"></div>
                </div>
                <span class="scroll-label">EXPLORE</span>
            </div>
        </section>

        <!-- ════════════════════════════════════════════════════════════════
             BRIEFING DOSSIER
             The page is a classified briefing, not a website.
             Chapters advance toward one action: Request NDA Briefing.
        ════════════════════════════════════════════════════════════════ -->
        <div class="briefing-dossier">

            <!-- ═══════════════════════════════════════
                 CHAPTER 01: SOVEREIGN BY CONSTRUCTION
            ═══════════════════════════════════════ -->
            <article class="chapter-plate" id="ch-sovereign" data-chapter="1">
                <div class="calibration-mark"></div>
                <span class="chapter-code">CH-01 / SOVEREIGN</span>
                <div class="chapter-content">
                    <h2 class="chapter-stamp">SOVEREIGN.</h2>
                    <p class="chapter-claim">
                        Zero external dependencies. No API calls. No cloud inference.
                        The entire system runs on your infrastructure with complete network isolation.
                    </p>

                    <div class="chapter-artifact">
                        <span class="artifact-label">DEPENDENCY BOUNDARY</span>
                        <div class="artifact-visual">
                            <svg viewBox="0 0 400 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <!-- External world (crossed out) -->
                                <rect x="20" y="20" width="100" height="80" stroke="#4a3d1a" stroke-width="1" fill="none" stroke-dasharray="4 2"/>
                                <text x="70" y="55" fill="#4a3d1a" font-family="monospace" font-size="9" text-anchor="middle">EXTERNAL</text>
                                <text x="70" y="70" fill="#4a3d1a" font-family="monospace" font-size="9" text-anchor="middle">SERVICES</text>
                                <line x1="20" y1="20" x2="120" y2="100" stroke="#7a6428" stroke-width="1"/>
                                <line x1="120" y1="20" x2="20" y2="100" stroke="#7a6428" stroke-width="1"/>

                                <!-- Boundary wall -->
                                <line x1="160" y1="10" x2="160" y2="110" stroke="#d4af37" stroke-width="2"/>
                                <text x="160" y="125" fill="#7a6428" font-family="monospace" font-size="8" text-anchor="middle">BOUNDARY</text>

                                <!-- Internal sovereign zone -->
                                <rect x="200" y="20" width="180" height="80" stroke="#d4af37" stroke-width="1" fill="rgba(212,175,55,0.03)"/>
                                <text x="290" y="45" fill="#d4af37" font-family="monospace" font-size="10" text-anchor="middle">CYTHERAI</text>
                                <text x="290" y="62" fill="#9c9b96" font-family="monospace" font-size="8" text-anchor="middle">tokenizer + weights + inference</text>
                                <text x="290" y="78" fill="#9c9b96" font-family="monospace" font-size="8" text-anchor="middle">127.0.0.1</text>
                            </svg>
                        </div>
                    </div>

                    <p class="chapter-consequence">
                        <strong>RESULT:</strong> Deployable in air-gapped, constrained, and regulated environments.
                    </p>

                    <div class="chapter-expand">
                        <button class="expand-trigger" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('open')">
                            TECHNICAL DETAIL <span class="arrow">+</span>
                        </button>
                        <div class="expand-content">
                            <div class="expand-inner">
                                <ul class="expand-bullets">
                                    <li>No OpenAI, Anthropic, or third-party inference APIs</li>
                                    <li>Custom tokenizer trained on domain-specific corpora</li>
                                    <li>Weights stored locally; never transmitted</li>
                                    <li>Zero egress by default; network calls require explicit allowlist</li>
                                    <li>Suitable for defense, healthcare, and financial deployments</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <!-- ═══════════════════════════════════════
                 CHAPTER 02: FROM SCRATCH, NOT BORROWED
            ═══════════════════════════════════════ -->
            <article class="chapter-plate" id="ch-scratch" data-chapter="2">
                <div class="calibration-mark"></div>
                <span class="chapter-code">CH-02 / FROM SCRATCH</span>
                <div class="chapter-content">
                    <h2 class="chapter-stamp">FROM SCRATCH.</h2>
                    <p class="chapter-claim">
                        Random initialization. No pretrained foundation model. No inherited weights.
                        Every parameter learned from first principles on curated data.
                    </p>

                    <div class="chapter-artifact">
                        <span class="artifact-label">INITIALIZATION → CONVERGENCE</span>
                        <div class="artifact-visual">
                            <svg viewBox="0 0 400 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <!-- Random init (noise) -->
                                <g opacity="0.6">
                                    <circle cx="40" cy="50" r="3" fill="#4a3d1a"/>
                                    <circle cx="55" cy="35" r="2" fill="#4a3d1a"/>
                                    <circle cx="30" cy="65" r="2" fill="#4a3d1a"/>
                                    <circle cx="60" cy="55" r="2" fill="#4a3d1a"/>
                                    <circle cx="45" cy="40" r="2" fill="#4a3d1a"/>
                                    <circle cx="35" cy="55" r="2" fill="#4a3d1a"/>
                                    <circle cx="50" cy="70" r="2" fill="#4a3d1a"/>
                                </g>
                                <text x="45" y="92" fill="#4a3d1a" font-family="monospace" font-size="8" text-anchor="middle">RANDOM</text>

                                <!-- Arrow progression -->
                                <line x1="80" y1="50" x2="320" y2="50" stroke="#7a6428" stroke-width="1" stroke-dasharray="4 2"/>
                                <polygon points="320,50 310,45 310,55" fill="#7a6428"/>

                                <!-- Training epochs indicators -->
                                <g>
                                    <line x1="120" y1="45" x2="120" y2="55" stroke="#7a6428" stroke-width="1"/>
                                    <line x1="180" y1="45" x2="180" y2="55" stroke="#7a6428" stroke-width="1"/>
                                    <line x1="240" y1="45" x2="240" y2="55" stroke="#7a6428" stroke-width="1"/>
                                </g>

                                <!-- Converged structure -->
                                <g>
                                    <circle cx="360" cy="50" r="20" stroke="#d4af37" stroke-width="1" fill="none"/>
                                    <circle cx="360" cy="50" r="8" fill="#d4af37"/>
                                    <line x1="360" y1="30" x2="360" y2="35" stroke="#d4af37" stroke-width="1"/>
                                    <line x1="360" y1="65" x2="360" y2="70" stroke="#d4af37" stroke-width="1"/>
                                    <line x1="340" y1="50" x2="345" y2="50" stroke="#d4af37" stroke-width="1"/>
                                    <line x1="375" y1="50" x2="380" y2="50" stroke="#d4af37" stroke-width="1"/>
                                </g>
                                <text x="360" y="92" fill="#d4af37" font-family="monospace" font-size="8" text-anchor="middle">CONVERGED</text>
                            </svg>
                        </div>
                    </div>

                    <p class="chapter-consequence">
                        <strong>RESULT:</strong> No inherited bias or dependency chains from upstream models.
                    </p>

                    <div class="chapter-expand">
                        <button class="expand-trigger" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('open')">
                            TECHNICAL DETAIL <span class="arrow">+</span>
                        </button>
                        <div class="expand-content">
                            <div class="expand-inner">
                                <ul class="expand-bullets">
                                    <li>Xavier/He initialization from random seed</li>
                                    <li>No transfer learning from GPT, LLaMA, or other foundations</li>
                                    <li>Training data fully curated and auditable</li>
                                    <li>Provenance chain from initialization to deployment</li>
                                    <li>No license encumbrance from upstream model weights</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <!-- ═══════════════════════════════════════
                 CHAPTER 03: REPRODUCIBLE END-TO-END
            ═══════════════════════════════════════ -->
            <article class="chapter-plate" id="ch-reproducible" data-chapter="3">
                <div class="calibration-mark"></div>
                <span class="chapter-code">CH-03 / REPRODUCIBLE</span>
                <div class="chapter-content">
                    <h2 class="chapter-stamp">REPRODUCIBLE.</h2>
                    <p class="chapter-claim">
                        Same seed, same result. Tokenizer, training, and weights are deterministic.
                        Full pipeline can be replayed and verified independently.
                    </p>

                    <div class="chapter-artifact">
                        <span class="artifact-label">DETERMINISTIC PIPELINE</span>
                        <div class="artifact-visual">
                            <svg viewBox="0 0 400 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <!-- Pipeline stages -->
                                <rect x="20" y="25" width="70" height="30" stroke="#7a6428" stroke-width="1" fill="none"/>
                                <text x="55" y="44" fill="#9c9b96" font-family="monospace" font-size="8" text-anchor="middle">TOKENIZER</text>

                                <line x1="95" y1="40" x2="115" y2="40" stroke="#7a6428" stroke-width="1"/>
                                <polygon points="115,40 110,37 110,43" fill="#7a6428"/>

                                <rect x="120" y="25" width="70" height="30" stroke="#7a6428" stroke-width="1" fill="none"/>
                                <text x="155" y="44" fill="#9c9b96" font-family="monospace" font-size="8" text-anchor="middle">TRAINING</text>

                                <line x1="195" y1="40" x2="215" y2="40" stroke="#7a6428" stroke-width="1"/>
                                <polygon points="215,40 210,37 210,43" fill="#7a6428"/>

                                <rect x="220" y="25" width="70" height="30" stroke="#7a6428" stroke-width="1" fill="none"/>
                                <text x="255" y="44" fill="#9c9b96" font-family="monospace" font-size="8" text-anchor="middle">WEIGHTS</text>

                                <line x1="295" y1="40" x2="315" y2="40" stroke="#d4af37" stroke-width="1"/>
                                <polygon points="315,40 310,37 310,43" fill="#d4af37"/>

                                <!-- Checkpoint seal -->
                                <circle cx="355" cy="40" r="20" stroke="#d4af37" stroke-width="1" fill="rgba(212,175,55,0.05)"/>
                                <text x="355" y="38" fill="#d4af37" font-family="monospace" font-size="7" text-anchor="middle">SEALED</text>
                                <text x="355" y="48" fill="#d4af37" font-family="monospace" font-size="6" text-anchor="middle">CKPT</text>

                                <!-- Seed indicator -->
                                <text x="55" y="70" fill="#4a3d1a" font-family="monospace" font-size="7" text-anchor="middle">seed: 0x...</text>
                                <text x="155" y="70" fill="#4a3d1a" font-family="monospace" font-size="7" text-anchor="middle">seed: 0x...</text>
                            </svg>
                        </div>
                    </div>

                    <p class="chapter-consequence">
                        <strong>RESULT:</strong> Auditability and repeatability for compliance-sensitive deployments.
                    </p>

                    <div class="chapter-expand">
                        <button class="expand-trigger" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('open')">
                            TECHNICAL DETAIL <span class="arrow">+</span>
                        </button>
                        <div class="expand-content">
                            <div class="expand-inner">
                                <ul class="expand-bullets">
                                    <li>Fixed random seeds at every stochastic operation</li>
                                    <li>Tokenizer vocabulary frozen and versioned</li>
                                    <li>Training hyperparameters locked in config manifests</li>
                                    <li>Checkpoint hashes for integrity verification</li>
                                    <li>Third-party auditors can reproduce training from scratch</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <!-- ═══════════════════════════════════════
                 SOFT GATE - Mid-briefing conversion point
            ═══════════════════════════════════════ -->
            <div class="gate-soft">
                <p class="gate-line">FOR FULL TECHNICAL DISCLOSURE</p>
                <a href="mailto:nda@cytherai.com?subject=NDA%20Briefing%20Request" class="gate-cta">REQUEST NDA BRIEFING</a>
            </div>

            <!-- ═══════════════════════════════════════
                 CHAPTER 04: THEOREM-PROVING CAPABILITY
            ═══════════════════════════════════════ -->
            <article class="chapter-plate" id="ch-reasoning" data-chapter="4">
                <div class="calibration-mark"></div>
                <span class="chapter-code">CH-04 / REASONING</span>
                <div class="chapter-content">
                    <h2 class="chapter-stamp">REASONING.</h2>
                    <p class="chapter-claim">
                        Neural-symbolic architecture with formal proof discipline.
                        Contradiction detection prevents hallucination. Every inference is auditable.
                    </p>

                    <div class="chapter-artifact">
                        <span class="artifact-label">INFERENCE GLYPH MAP</span>
                        <div class="artifact-visual">
                            <svg viewBox="0 0 400 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <!-- Neural side -->
                                <g>
                                    <circle cx="60" cy="30" r="8" stroke="#7a6428" stroke-width="1" fill="none"/>
                                    <circle cx="40" cy="50" r="8" stroke="#7a6428" stroke-width="1" fill="none"/>
                                    <circle cx="80" cy="50" r="8" stroke="#7a6428" stroke-width="1" fill="none"/>
                                    <circle cx="60" cy="70" r="8" stroke="#7a6428" stroke-width="1" fill="none"/>
                                    <line x1="60" y1="38" x2="48" y2="44" stroke="#7a6428" stroke-width="0.5"/>
                                    <line x1="60" y1="38" x2="72" y2="44" stroke="#7a6428" stroke-width="0.5"/>
                                    <line x1="48" y1="56" x2="54" y2="64" stroke="#7a6428" stroke-width="0.5"/>
                                    <line x1="72" y1="56" x2="66" y2="64" stroke="#7a6428" stroke-width="0.5"/>
                                </g>
                                <text x="60" y="95" fill="#7a6428" font-family="monospace" font-size="7" text-anchor="middle">NEURAL</text>

                                <!-- Fusion zone -->
                                <line x1="110" y1="50" x2="170" y2="50" stroke="#d4af37" stroke-width="1"/>
                                <circle cx="140" cy="50" r="3" fill="#d4af37"/>

                                <!-- Symbolic side -->
                                <g>
                                    <text x="220" y="35" fill="#7a6428" font-family="serif" font-size="14" font-style="italic" text-anchor="middle">P</text>
                                    <text x="240" y="50" fill="#7a6428" font-family="monospace" font-size="10" text-anchor="middle">→</text>
                                    <text x="260" y="35" fill="#7a6428" font-family="serif" font-size="14" font-style="italic" text-anchor="middle">Q</text>
                                    <line x1="200" y1="55" x2="280" y2="55" stroke="#7a6428" stroke-width="1"/>
                                    <text x="240" y="75" fill="#7a6428" font-family="serif" font-size="14" font-style="italic" text-anchor="middle">Q</text>
                                </g>
                                <text x="240" y="95" fill="#7a6428" font-family="monospace" font-size="7" text-anchor="middle">SYMBOLIC</text>

                                <!-- Output: Verified -->
                                <line x1="290" y1="50" x2="330" y2="50" stroke="#d4af37" stroke-width="1"/>
                                <polygon points="330,50 325,47 325,53" fill="#d4af37"/>

                                <rect x="340" y="35" width="50" height="30" stroke="#d4af37" stroke-width="1" fill="rgba(212,175,55,0.05)"/>
                                <text x="365" y="54" fill="#d4af37" font-family="monospace" font-size="8" text-anchor="middle">VERIFIED</text>
                            </svg>
                        </div>
                    </div>

                    <p class="chapter-consequence">
                        <strong>RESULT:</strong> Correctness guarantees and contradiction handling for critical decisions.
                    </p>

                    <div class="chapter-expand">
                        <button class="expand-trigger" onclick="this.classList.toggle('open'); this.nextElementSibling.classList.toggle('open')">
                            TECHNICAL DETAIL <span class="arrow">+</span>
                        </button>
                        <div class="expand-content">
                            <div class="expand-inner">
                                <ul class="expand-bullets">
                                    <li>Hybrid neural-symbolic inference architecture</li>
                                    <li>Built-in consistency checking at inference time</li>
                                    <li>Formal proof traces for each reasoning step</li>
                                    <li>Contradiction detection before output generation</li>
                                    <li>Replayable audit logs for every decision</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <!-- ═══════════════════════════════════════
                 CHAPTER 05: PORTFOLIO (CYTHECTOR)
            ═══════════════════════════════════════ -->
            <article class="chapter-plate" id="ch-portfolio" data-chapter="5">
                <div class="calibration-mark"></div>
                <span class="chapter-code">CH-05 / PORTFOLIO</span>
                <div class="chapter-content">
                    <h2 class="chapter-stamp">ALSO BUILT.</h2>
                    <p class="chapter-claim">
                        The same sovereign methodology applied to domain-specific models.
                        Cythector: a local cinematic director LLM for film and virtual production.
                    </p>

                    <div class="portfolio-card">
                        <div class="portfolio-logo">
                            <img src="/cythector_logo.svg" alt="Cythector">
                        </div>
                        <div class="portfolio-info">
                            <h4>CYTHECTOR</h4>
                            <p>
                                Transforms narrative scene descriptions into structured cinematic breakdowns.
                                100% local. Zero external API dependency.
                            </p>
                            <a href="/bots/cythector/" class="portfolio-link">
                                CytherAI-DirectorBot/1.0 <span>→</span>
                            </a>
                        </div>
                    </div>

                    <p class="chapter-consequence">
                        <strong>RESULT:</strong> Proof of methodology. Sovereign models for specialized domains.
                    </p>
                </div>
            </article>

            <!-- ═══════════════════════════════════════
                 CHAPTER 06: BRIEFING GATE (HARD CTA)
            ═══════════════════════════════════════ -->
            <article class="chapter-plate" id="ch-gate" data-chapter="6">
                <div class="calibration-mark"></div>
                <span class="chapter-code">CH-06 / GATE</span>
                <div class="chapter-content">
                    <div class="gate-hard">
                        <h2 class="gate-stamp">BRIEFING GATE</h2>
                        <p class="gate-subline">
                            Full technical disclosure requires NDA.
                            Architecture details, training methodology, and deployment specifications.
                        </p>
                        <a href="mailto:nda@cytherai.com?subject=NDA%20Briefing%20Request" class="gate-cta-primary">
                            REQUEST NDA BRIEFING
                        </a>
                    </div>
                </div>
            </article>

        </div><!-- end .briefing-dossier -->
    </main>

    <!-- Footer -->
    <footer>
        <div class="footer-brand">
            <svg viewBox="0 0 24 28" fill="none">
                <polygon points="12,1 16,8 8,8" fill="#D4AF37"/>
                <polygon points="5,5 8,10 2,10" fill="#B8942A"/>
                <polygon points="19,5 22,10 16,10" fill="#B8942A"/>
                <path d="M 1 12 Q 12 16 23 12" stroke="#D4AF37" stroke-width="1" fill="none"/>
                <text x="12" y="22" fill="#D4AF37" font-family="serif" font-size="12" font-style="italic" text-anchor="middle" dominant-baseline="middle">λ</text>
            </svg>
            <span class="footer-brand-text">© <span id="year"></span> CYTHERAI — ALL RIGHTS RESERVED</span>
        </div>
        <div class="footer-links">
            <span>Riyadh (UTC+3)</span>
            <span>EN / AR</span>
        </div>
    </footer>

    <script>
        // ========================================
        // INITIALIZATION
        // ========================================
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        
        document.getElementById('year').textContent = new Date().getFullYear();

        // DNA Helix Loading Animation
        function generateDNAHelix() {
            const strand = document.getElementById('dnaStrand');
            if (!strand) return;
            for (let i = 0; i < 16; i++) {
                const base = document.createElement('div');
                base.className = 'dna-base';
                base.style.top = (i * 10) + 'px';
                base.style.transform = `rotateY(${i * 22.5}deg)`;
                strand.appendChild(base);
            }
        }
        generateDNAHelix();

        // Loading Screen
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('consciousness3D').classList.add('active');
                initScramble();
                initTransformation();
            }, 1800);
        });

        // ========================================
        // ENHANCED MAGNETIC CURSOR SYSTEM
        // ========================================
        if (!isMobile) {
            const cursorCore = document.getElementById('cursorCore');
            const cursorAura = document.getElementById('cursorAura');
            let mouseX = 0, mouseY = 0, coreX = 0, coreY = 0, auraX = 0, auraY = 0;
            let currentTarget = null;
            const magneticElements = document.querySelectorAll('a, button, .feature-card, .concept-tag, .logo-container, .awakening-node, .cta-button');

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            }, { passive: true });

            function animateCursor() {
                let targetX = mouseX;
                let targetY = mouseY;

                // Magnetic attraction to interactive elements
                if (currentTarget) {
                    const rect = currentTarget.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2));

                    // Apply magnetic pull within 100px radius
                    if (distance < 100) {
                        const strength = (100 - distance) / 100 * 0.3;
                        targetX += (centerX - mouseX) * strength;
                        targetY += (centerY - mouseY) * strength;
                    }
                }

                coreX += (targetX - coreX) * 0.25;
                coreY += (targetY - coreY) * 0.25;
                auraX += (targetX - auraX) * 0.1;
                auraY += (targetY - auraY) * 0.1;

                cursorCore.style.transform = `translate(${coreX - 4}px, ${coreY - 4}px)`;
                cursorAura.style.transform = `translate(${auraX - 22}px, ${auraY - 22}px)`;

                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            magneticElements.forEach(el => {
                el.addEventListener('mouseenter', () => {
                    cursorAura.classList.add('hover');
                    cursorCore.classList.add('magnetic');
                    cursorAura.classList.add('magnetic');
                    currentTarget = el;
                });
                el.addEventListener('mouseleave', () => {
                    cursorAura.classList.remove('hover');
                    cursorCore.classList.remove('magnetic');
                    cursorAura.classList.remove('magnetic');
                    currentTarget = null;
                });
            });
        }

        // ========================================
        // NEURAL FIELD
        // ========================================
        function generateNeuralField() {
            const field = document.getElementById('neuralField');
            if (!field) return;
            
            const nodeCount = isMobile ? 25 : 55;
            const nodes = [];

            for (let i = 0; i < nodeCount; i++) {
                const node = document.createElement('div');
                node.className = 'synapse-node';
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                node.style.left = x + '%';
                node.style.top = y + '%';
                node.style.animationDelay = (Math.random() * 6) + 's';
                field.appendChild(node);
                nodes.push({ x, y });
            }

            if (!isMobile) {
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[j].x - nodes[i].x;
                        const dy = nodes[j].y - nodes[i].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 22 && Math.random() > 0.5) {
                            const conn = document.createElement('div');
                            conn.className = 'neural-connection';
                            conn.style.left = nodes[i].x + '%';
                            conn.style.top = nodes[i].y + '%';
                            conn.style.width = distance + '%';
                            conn.style.transform = `rotate(${Math.atan2(dy, dx) * 180 / Math.PI}deg)`;
                            conn.style.animationDelay = (Math.random() * 4) + 's';
                            field.appendChild(conn);
                        }
                    }
                }
            }
        }
        generateNeuralField();

        // ========================================
        // TEXT SCRAMBLE
        // ========================================
        class TextScrambler {
            constructor(el) {
                this.el = el;
                this.chars = '!<>-_\\/[]{}—=+*^?#λ∀∃∴∵⊢⊨∧∨¬→↔∈∉⊂⊃';
            }
            setText(newText) {
                const oldText = this.el.innerText;
                const length = Math.max(oldText.length, newText.length);
                const promise = new Promise((resolve) => this.resolve = resolve);
                this.queue = [];
                for (let i = 0; i < length; i++) {
                    const from = oldText[i] || '';
                    const to = newText[i] || '';
                    const start = Math.floor(Math.random() * 40);
                    const end = start + Math.floor(Math.random() * 40);
                    this.queue.push({ from, to, start, end });
                }
                cancelAnimationFrame(this.frameRequest);
                this.frame = 0;
                this.update();
                return promise;
            }
            update() {
                let output = '';
                let complete = 0;
                for (let i = 0; i < this.queue.length; i++) {
                    let { from, to, start, end, char } = this.queue[i];
                    if (this.frame >= end) {
                        complete++;
                        output += to;
                    } else if (this.frame >= start) {
                        if (!char || Math.random() < 0.28) {
                            char = this.chars[Math.floor(Math.random() * this.chars.length)];
                            this.queue[i].char = char;
                        }
                        output += `<span class="char scrambling">${char}</span>`;
                    } else {
                        output += from;
                    }
                }
                this.el.innerHTML = output;
                if (complete === this.queue.length) {
                    this.resolve();
                } else {
                    this.frameRequest = requestAnimationFrame(() => this.update());
                    this.frame++;
                }
            }
        }

        function initScramble() {
            const el = document.getElementById('scrambleText');
            if (!el) return;
            const fx = new TextScrambler(el);
            const phrases = [
                'SOVEREIGN VERIFIABLE INTELLIGENCE',
                'NEURAL THEOREM PROVER',
                'WHERE THOUGHT BECOMES FORM',
                'ZERO DEPENDENCY ARCHITECTURE',
                '97.7% LOSS REDUCTION',
                'PROOF GENERATION SYSTEM'
            ];
            let counter = 0;
            const next = () => {
                fx.setText(phrases[counter]).then(() => setTimeout(next, 3500));
                counter = (counter + 1) % phrases.length;
            };
            next();
        }

        // ========================================
        // THOUGHT BECOMES FORM TRANSFORMATION
        // ========================================
        function initTransformation() {
            if (prefersReducedMotion || isMobile) return;

            const container = document.getElementById('thoughtSymbols');
            const proofTree = document.getElementById('proofTree');
            if (!container || !proofTree) return;

            // Mathematical symbols representing "thought"
            const symbols = ['∀', '∃', '∧', '∨', '¬', '→', '↔', '⊢', '⊨', '≡', '∈', '∉', '⊂', '⊃', 'λ', '∴', '∵'];
            const symbolElements = [];

            // Phase 1: Scattered symbols appear (0-1.5s)
            symbols.forEach((symbol, i) => {
                setTimeout(() => {
                    const el = document.createElement('div');
                    el.className = 'thought-symbol';
                    el.textContent = symbol;

                    // Random scattered position
                    const x = 50 + (Math.random() - 0.5) * 500;
                    const y = 50 + (Math.random() - 0.5) * 300;
                    const rotation = (Math.random() - 0.5) * 60;

                    el.style.left = x + 'px';
                    el.style.top = y + 'px';
                    el.style.setProperty('--rotation', rotation + 'deg');
                    el.style.animationDelay = (i * 0.08) + 's';

                    container.appendChild(el);
                    symbolElements.push({ el, x, y, rotation });
                }, i * 80);
            });

            // Phase 2: Symbols drift organically (1.5-3.5s)
            setTimeout(() => {
                symbolElements.forEach(({ el, x, y }, i) => {
                    const driftX = (Math.random() - 0.5) * 100;
                    const driftY = (Math.random() - 0.5) * 80;

                    el.style.setProperty('--drift-x', driftX);
                    el.style.setProperty('--drift-y', driftY);
                    el.classList.add('drifting');
                });
            }, 1500);

            // Phase 3: Symbols converge to center (3.5-4.7s)
            setTimeout(() => {
                symbolElements.forEach(({ el }, i) => {
                    const rect = el.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    // Calculate path to center of container
                    const currentX = rect.left - containerRect.left + rect.width / 2;
                    const currentY = rect.top - containerRect.top + rect.height / 2;
                    const targetX = 300 - currentX;
                    const targetY = 200 - currentY;

                    el.style.setProperty('--target-x', targetX + 'px');
                    el.style.setProperty('--target-y', targetY + 'px');
                    el.classList.remove('drifting');
                    el.classList.add('converging');

                    // Remove symbol after convergence
                    setTimeout(() => el.remove(), 1200);
                });
            }, 3500);

            // Phase 4: Proof tree crystallizes (4.7s)
            setTimeout(() => {
                proofTree.classList.add('crystallized');
            }, 4700);
        }

        // ========================================
        // AWAKENING METER
        // ========================================
        const awakeningFill = document.getElementById('awakeningFill');
        const awakeningNodes = document.querySelectorAll('.awakening-node');
        const sections = ['hero', 'foundation', 'intelligence', 'sovereignty', 'nexus'];

        function updateAwakening() {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = Math.min((scrollTop / docHeight) * 100, 100);
            
            if (awakeningFill) {
                awakeningFill.style.height = progress + '%';
            }

            sections.forEach((section, index) => {
                const el = document.getElementById(section);
                if (el && awakeningNodes[index]) {
                    const rect = el.getBoundingClientRect();
                    const isActive = rect.top < window.innerHeight / 2 && rect.bottom > 0;
                    awakeningNodes[index].classList.toggle('active', isActive);
                }
            });
        }

        window.addEventListener('scroll', updateAwakening, { passive: true });
        updateAwakening();

        // ========================================
        // NAVIGATION
        // ========================================
        const nav = document.getElementById('nav');
        window.addEventListener('scroll', () => {
            nav.classList.toggle('scrolled', window.scrollY > 80);
        }, { passive: true });

        // ========================================
        // REVEAL ON SCROLL
        // ========================================
        const revealObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) entry.target.classList.add('active');
            });
        }, { threshold: 0.1, rootMargin: '-50px' });

        document.querySelectorAll('.reveal').forEach(el => revealObserver.observe(el));

        // ========================================
        // ENHANCED FEATURE CARD 3D TILT & MOUSE EFFECT
        // ========================================
        document.querySelectorAll('.feature-card').forEach(card => {
            card.addEventListener('mousemove', (e) => {
                const rect = card.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 100;
                const y = ((e.clientY - rect.top) / rect.height) * 100;
                card.style.setProperty('--mouse-x', x + '%');
                card.style.setProperty('--mouse-y', y + '%');

                // 3D tilt effect
                if (!isMobile) {
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const deltaX = (e.clientX - centerX) / (rect.width / 2);
                    const deltaY = (e.clientY - centerY) / (rect.height / 2);

                    const rotateX = deltaY * -8; // Max 8deg tilt
                    const rotateY = deltaX * 8;

                    card.style.transform = `translateY(-8px) perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(1.02, 1.02, 1.02)`;
                }
            });

            card.addEventListener('mouseleave', () => {
                card.style.transform = '';
            });
        });

        // ========================================
        // LOGO GLOW PROXIMITY
        // ========================================
        const logoContainer = document.getElementById('logoContainer');
        if (!isMobile && logoContainer) {
            document.addEventListener('mousemove', (e) => {
                const rect = logoContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const distance = Math.sqrt(Math.pow(e.clientX - centerX, 2) + Math.pow(e.clientY - centerY, 2));
                const maxDistance = 450;
                const intensity = Math.max(0, 1 - (distance / maxDistance));
                const glow = logoContainer.querySelector('.logo-glow');
                if (glow) glow.style.opacity = intensity * 0.9;
            }, { passive: true });
        }

        // ========================================
        // INTERACTIONS
        // ========================================
        document.getElementById('ctaButton').addEventListener('click', () => {
            document.getElementById('nexus').scrollIntoView({ behavior: 'smooth' });
        });

        document.getElementById('copyBtn').addEventListener('click', async () => {
            const email = document.getElementById('contactEmail').textContent;
            try {
                await navigator.clipboard.writeText(email);
                document.getElementById('copyBtn').textContent = 'COPIED!';
                setTimeout(() => document.getElementById('copyBtn').textContent = 'COPY EMAIL', 2000);
            } catch (err) {}
        });

        document.getElementById('contactForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const data = new FormData(e.target);
            const subject = encodeURIComponent(data.get('subject') || 'CytherAI Inquiry');
            const body = encodeURIComponent(`Name: ${data.get('name')}\nOrganization: ${data.get('org')}\n\n${data.get('message')}`);
            window.location.href = `mailto:Aethersdev@cytherAi.com?subject=${subject}&body=${body}`;
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href === '#') return;
                e.preventDefault();
                const target = document.querySelector(href);
                if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // ========================================
        // 2025 CUTTING-EDGE ENHANCEMENTS
        // ========================================

        // Apply Liquid Glass to Navigation
        if (nav) {
            nav.classList.add('liquid-glass-nav');
        }

        // Generate Morphic Resonance Field Threads
        function generateMorphicField() {
            if (isMobile || prefersReducedMotion) return;
            const field = document.getElementById('morphicField');
            if (!field) return;

            const svg = field.querySelector('svg');
            const threadCount = 12;

            for (let i = 0; i < threadCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const startX = Math.random() * 100;
                const startY = Math.random() * 100;
                const endX = startX + (Math.random() - 0.5) * 40;
                const endY = startY + (Math.random() - 0.5) * 40;

                line.setAttribute('x1', startX + '%');
                line.setAttribute('y1', startY + '%');
                line.setAttribute('x2', endX + '%');
                line.setAttribute('y2', endY + '%');
                line.setAttribute('stroke', 'url(#morphicGradient)');
                line.setAttribute('stroke-width', '0.5');
                line.style.opacity = '0';
                line.style.animation = `morphicPulse ${6 + Math.random() * 4}s ease-in-out ${Math.random() * 5}s infinite`;

                svg.appendChild(line);
            }
        }
        generateMorphicField();

        // Generate Quantum Entanglement Threads
        function generateQuantumThreads() {
            if (isMobile || prefersReducedMotion) return;
            const svg = document.getElementById('quantumThreads');
            if (!svg) return;

            const points = [];
            const pointCount = 8;

            for (let i = 0; i < pointCount; i++) {
                points.push({
                    x: 10 + Math.random() * 80,
                    y: 10 + Math.random() * 80
                });
            }

            // Create connecting paths
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    if (Math.random() > 0.6) continue;

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const midX = (points[i].x + points[j].x) / 2 + (Math.random() - 0.5) * 20;
                    const midY = (points[i].y + points[j].y) / 2 + (Math.random() - 0.5) * 20;

                    const d = `M ${points[i].x}% ${points[i].y}% Q ${midX}% ${midY}% ${points[j].x}% ${points[j].y}%`;
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', 'url(#threadGrad)');
                    path.setAttribute('stroke-width', '0.3');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-dasharray', '100');
                    path.setAttribute('stroke-dashoffset', '100');
                    path.style.animation = `quantumEntangle ${4 + Math.random() * 4}s ease-in-out ${Math.random() * 4}s infinite`;

                    svg.appendChild(path);
                }
            }

            // Activate after load
            setTimeout(() => svg.classList.add('active'), 2500);
        }
        generateQuantumThreads();

        // Generate Data Streams
        function generateDataStreams() {
            if (isMobile || prefersReducedMotion) return;
            const container = document.getElementById('dataStreamContainer');
            if (!container) return;

            const streamCount = 6;
            const chars = '01λ∀∃∧∨¬→⊢⊨ψΩΔ∫∑∏√∞≈≠≤≥αβγδεζηθικμνξπρσφχω';

            for (let i = 0; i < streamCount; i++) {
                const stream = document.createElement('div');
                stream.className = 'data-stream';
                stream.style.top = (15 + Math.random() * 70) + '%';
                stream.style.animationDuration = (15 + Math.random() * 15) + 's';
                stream.style.animationDelay = (Math.random() * 10) + 's';

                let text = '';
                for (let j = 0; j < 80; j++) {
                    text += chars[Math.floor(Math.random() * chars.length)] + ' ';
                }
                stream.textContent = text;

                container.appendChild(stream);
            }
        }
        generateDataStreams();

        // Generate Consciousness Particles
        function generateConsciousnessParticles() {
            if (isMobile || prefersReducedMotion) return;
            const container = document.getElementById('consciousnessParticles');
            if (!container) return;

            const particleCount = 20;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'c-particle';
                particle.style.left = (5 + Math.random() * 90) + '%';
                particle.style.animationDuration = (12 + Math.random() * 8) + 's';
                particle.style.animationDelay = (Math.random() * 15) + 's';

                const size = 1 + Math.random() * 2;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';

                container.appendChild(particle);
            }
        }
        generateConsciousnessParticles();

        // Add Holographic Overlay to Feature Cards
        function addHoloOverlays() {
            document.querySelectorAll('.feature-card').forEach(card => {
                const holoOverlay = document.createElement('div');
                holoOverlay.className = 'holo-overlay';
                card.appendChild(holoOverlay);
            });
        }
        addHoloOverlays();

        // Enhanced Glow Text Effect
        document.querySelectorAll('.section-title').forEach(title => {
            title.classList.add('glow-text');
        });

        // ========================================
        // SMOOTH SCROLL & PARALLAX SYSTEM
        // ========================================
        if (!isMobile && !prefersReducedMotion) {
            let ticking = false;

            function updateParallax() {
                const scrolled = window.pageYOffset;

                // Parallax on hero elements
                const hero = document.getElementById('hero');
                if (hero) {
                    const heroHeight = hero.offsetHeight;
                    const progress = Math.min(scrolled / heroHeight, 1);

                    // Fade and transform hero content on scroll
                    const heroContent = hero.querySelector('.hero-content');
                    if (heroContent) {
                        heroContent.style.opacity = 1 - progress * 0.8;
                        heroContent.style.transform = `translateY(${scrolled * 0.3}px)`;
                    }

                    // Parallax on ambient orbs
                    const orbs = hero.querySelectorAll('.ambient-orb');
                    orbs.forEach((orb, i) => {
                        const speed = 0.15 + (i * 0.05);
                        orb.style.transform = `translateY(${scrolled * speed}px)`;
                    });

                    // Parallax on sacred geometry
                    const geometry = hero.querySelector('.sacred-geometry');
                    if (geometry) {
                        geometry.style.transform = `translate(-50%, -50%) translateY(${scrolled * 0.2}px) rotate(${scrolled * 0.05}deg)`;
                    }
                }

                // Parallax on section headers
                document.querySelectorAll('.section-header').forEach(header => {
                    const rect = header.getBoundingClientRect();
                    const scrollProgress = (window.innerHeight - rect.top) / window.innerHeight;
                    if (scrollProgress > 0 && scrollProgress < 1.5) {
                        header.style.transform = `translateY(${(1 - scrollProgress) * 30}px)`;
                        header.style.opacity = Math.min(scrollProgress * 1.2, 1);
                    }
                });

                ticking = false;
            }

            function requestTick() {
                if (!ticking) {
                    requestAnimationFrame(updateParallax);
                    ticking = true;
                }
            }

            window.addEventListener('scroll', requestTick, { passive: true });
            updateParallax(); // Initial call
        }
    </script>

    <!-- REALITY DEVICE SHADER - Cinema-grade visuals -->
    <!-- Paradigm Shift: From "WebGL art" to "filmed machine" -->
    <script>
        // Global camera and material state for shader communication
        window.RitualCamera = {
            iris: 0.0,           // 0=closed, 1=open (aperture)
            focus: 0.0,          // 0=far, 1=near (focus plane)
            exposure: 0.3,       // 0=dark, 1=bright
            vignette: 0.8,       // vignette intensity
            grain: 0.12,         // film grain amount
            chromatic: 0.0,      // chromatic aberration
            shutterSnap: 0.0,    // shutter flash (0-1, decays)
            materiality: 0.0,    // 0=paper, 0.5=glass, 1=metal
            sealProgress: 0.0,   // 0=hidden, 1=fully drawn
            lensBreathing: 0.0   // subtle FOV micro-changes
        };

        (function() {
            const canvas = document.getElementById('consciousnessShader');
            if (!canvas || isMobile) return;

            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            if (!gl) return;

            const vertexShader = `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;

            // ═══════════════════════════════════════════════════════════════
            // REALITY DEVICE SHADER
            // Cinema-grade visuals: Camera language + Material phases + Seal geometry
            // ═══════════════════════════════════════════════════════════════
            const fragmentShader = `
                precision highp float;
                uniform vec2 resolution;
                uniform float time;
                uniform vec2 mouse;

                // Camera language uniforms
                uniform float u_iris;
                uniform float u_focus;
                uniform float u_exposure;
                uniform float u_vignette;
                uniform float u_grain;
                uniform float u_chromatic;
                uniform float u_shutter;
                uniform float u_breathing;

                // Material phase uniforms
                uniform float u_materiality;

                // Seal geometry uniforms
                uniform float u_seal;
                uniform float u_seed;

                // ═══════════════════════════════════════
                // NOISE FUNCTIONS
                // ═══════════════════════════════════════
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                    vec2 i = floor(v + dot(v, C.yy));
                    vec2 x0 = v - i + dot(i, C.xx);
                    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i);
                    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                    m = m*m; m = m*m;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                    vec3 g;
                    g.x = a0.x * x0.x + h.x * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
                float hash1(float n) { return fract(sin(n) * 43758.5453123); }

                float fbm(vec2 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    for(int i = 0; i < 5; i++) {
                        value += amplitude * snoise(p);
                        p *= 2.0;
                        amplitude *= 0.5;
                    }
                    return value;
                }

                // ═══════════════════════════════════════
                // SDF PRIMITIVES FOR SEAL GEOMETRY
                // ═══════════════════════════════════════
                float sdCircle(vec2 p, float r) { return length(p) - r; }
                float sdLine(vec2 p, vec2 a, vec2 b) {
                    vec2 pa = p - a, ba = b - a;
                    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                    return length(pa - ba * h);
                }

                // ═══════════════════════════════════════
                // DETERMINISTIC SEAL GEOMETRY
                // Unique sigil from seed - razor sharp SDF
                // ═══════════════════════════════════════
                float sealGeometry(vec2 uv, float seed, float progress) {
                    if (progress <= 0.0) return 0.0;

                    float d = 1.0;
                    vec2 p = uv * 2.5;

                    // Generate deterministic radial strokes from seed
                    float numStrokes = 6.0 + floor(hash1(seed) * 4.0);
                    float baseAngle = hash1(seed + 1.0) * 6.28318;

                    for (float i = 0.0; i < 10.0; i++) {
                        if (i >= numStrokes) break;

                        float strokeProgress = clamp((progress - i / numStrokes) * numStrokes, 0.0, 1.0);
                        if (strokeProgress <= 0.0) continue;

                        float angle = baseAngle + i * 6.28318 / numStrokes + hash1(seed + i * 0.1) * 0.3;
                        float innerR = 0.15 + hash1(seed + i * 0.2) * 0.1;
                        float outerR = 0.35 + hash1(seed + i * 0.3) * 0.2;

                        float drawR = innerR + (outerR - innerR) * strokeProgress;

                        vec2 dir = vec2(cos(angle), sin(angle));
                        vec2 a = dir * innerR;
                        vec2 b = dir * drawR;

                        d = min(d, sdLine(p, a, b));
                    }

                    // Central ring
                    float ringProgress = clamp(progress * 1.5, 0.0, 1.0);
                    d = min(d, abs(sdCircle(p, 0.12 * ringProgress)) - 0.008);

                    // Outer ring (draws last)
                    float outerProgress = clamp((progress - 0.7) * 3.33, 0.0, 1.0);
                    if (outerProgress > 0.0) {
                        d = min(d, abs(sdCircle(p, 0.45 * outerProgress)) - 0.004);
                    }

                    // Lambda glyph at center
                    float lambdaProgress = clamp((progress - 0.8) * 5.0, 0.0, 1.0);
                    if (lambdaProgress > 0.0) {
                        vec2 lp = p * 8.0;
                        float lambda = sdLine(lp, vec2(-0.3, -0.4) * lambdaProgress, vec2(0.0, 0.4) * lambdaProgress);
                        lambda = min(lambda, sdLine(lp, vec2(0.0, 0.4) * lambdaProgress, vec2(0.3, -0.4) * lambdaProgress));
                        d = min(d, lambda / 8.0);
                    }

                    // Sharp anti-aliased edge
                    float lineWidth = 0.008 + 0.004 * (1.0 - u_materiality);
                    return smoothstep(lineWidth, lineWidth * 0.3, d);
                }

                // ═══════════════════════════════════════
                // MATERIAL PHASES
                // Paper (0) → Glass (0.5) → Metal (1)
                // ═══════════════════════════════════════
                vec3 paperMaterial(vec2 uv, float t) {
                    float fiber = fbm(uv * 40.0 + t * 0.01) * 0.15;
                    float lines = smoothstep(0.48, 0.5, fract(uv.x * 30.0 + snoise(uv * 5.0) * 0.1));
                    lines += smoothstep(0.48, 0.5, fract(uv.y * 30.0 + snoise(uv.yx * 5.0) * 0.1));
                    lines *= 0.08;
                    vec3 paperBase = vec3(0.06, 0.055, 0.045);
                    vec3 inkColor = vec3(0.15, 0.12, 0.08);
                    return paperBase + fiber * vec3(0.02) + lines * inkColor;
                }

                vec3 glassMaterial(vec2 uv, float t, vec3 baseColor) {
                    vec2 refractUV = uv + snoise(uv * 3.0 + t * 0.05) * 0.02;
                    float caustic = pow(snoise(refractUV * 8.0 + t * 0.1) * 0.5 + 0.5, 3.0);
                    float internalGlow = exp(-length(uv) * 2.0) * 0.3;
                    float edge = pow(length(uv), 2.0);
                    vec3 glassColor = baseColor * (1.0 + caustic * 0.4);
                    glassColor += vec3(0.8, 0.7, 0.5) * internalGlow;
                    glassColor = mix(glassColor, vec3(0.9, 0.85, 0.7), edge * 0.2);
                    return glassColor;
                }

                vec3 metalMaterial(vec2 uv, float t, vec3 baseColor) {
                    float d = length(uv);
                    vec2 lightDir = normalize(vec2(0.3, 0.5));
                    float specular = pow(max(0.0, dot(normalize(uv), lightDir)), 64.0);
                    float edgeSpec = pow(1.0 - abs(d - 0.3), 8.0) * 0.5;
                    float brushed = snoise(uv * vec2(2.0, 40.0) + t * 0.02) * 0.05;
                    vec3 metalColor = baseColor * (1.0 + brushed);
                    metalColor += vec3(1.0, 0.95, 0.8) * specular * 0.6;
                    metalColor += vec3(0.9, 0.8, 0.6) * edgeSpec;
                    return metalColor;
                }

                // ═══════════════════════════════════════
                // CAMERA EFFECTS
                // ═══════════════════════════════════════
                vec3 chromaticAberration(vec2 uv, vec3 color, float amount) {
                    if (amount <= 0.001) return color;
                    vec2 dir = uv * amount * 0.02;
                    float r = color.r * (1.0 + length(dir) * 2.0);
                    float b = color.b * (1.0 - length(dir) * 1.5);
                    return vec3(r, color.g, b);
                }

                float filmGrain(vec2 uv, float t, float amount) {
                    return (hash(uv * 1000.0 + t * 100.0) - 0.5) * amount;
                }

                // ═══════════════════════════════════════
                // MAIN RENDER
                // ═══════════════════════════════════════
                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * resolution) / min(resolution.x, resolution.y);
                    vec2 screenUV = gl_FragCoord.xy / resolution;

                    // Lens breathing
                    float breath = sin(time * 0.3) * u_breathing * 0.02;
                    uv *= 1.0 + breath;

                    float t = time * 0.008;

                    // ═══════════════════════════════════════
                    // BASE CONSCIOUSNESS FIELD
                    // ═══════════════════════════════════════
                    vec2 p = uv * 2.2;
                    vec2 flow1 = vec2(fbm(p + t * 0.5), fbm(p - t * 0.4));
                    vec2 flow2 = vec2(fbm(p - t * 0.3 + 10.0), fbm(p + t * 0.35 + 10.0));

                    float pattern1 = fbm(p + flow1 * 0.55);
                    float pattern2 = fbm(p - flow2 * 0.35);
                    float consciousness = pattern1 * 0.5 + pattern2 * 0.3 + 0.2;

                    // ═══════════════════════════════════════
                    // MATERIAL PHASE BLENDING
                    // ═══════════════════════════════════════
                    vec3 goldShadow = vec3(0.24, 0.18, 0.04);
                    vec3 goldCore = vec3(0.83, 0.69, 0.22);
                    vec3 gold = vec3(0.72, 0.58, 0.16);

                    vec3 baseColor = mix(goldShadow, goldCore, consciousness);

                    vec3 paperPhase = paperMaterial(uv, t);
                    vec3 glassPhase = glassMaterial(uv, t, baseColor);
                    vec3 metalPhase = metalMaterial(uv, t, baseColor);

                    vec3 materialColor;
                    if (u_materiality < 0.5) {
                        materialColor = mix(paperPhase, glassPhase, u_materiality * 2.0);
                    } else {
                        materialColor = mix(glassPhase, metalPhase, (u_materiality - 0.5) * 2.0);
                    }

                    vec3 color = mix(baseColor * consciousness, materialColor, u_materiality * 0.7);

                    // ═══════════════════════════════════════
                    // SEAL GEOMETRY OVERLAY
                    // ═══════════════════════════════════════
                    float seal = sealGeometry(uv, u_seed, u_seal);
                    vec3 sealColor = mix(gold, vec3(1.0, 0.95, 0.85), u_materiality);
                    float emboss = u_shutter * seal * 0.3;
                    sealColor += emboss * vec3(1.0, 0.9, 0.7);
                    color = mix(color, sealColor, seal * u_seal);

                    // ═══════════════════════════════════════
                    // CAMERA LANGUAGE
                    // ═══════════════════════════════════════

                    // Iris / Aperture opening
                    float irisRadius = mix(0.0, 1.5, u_iris);
                    float irisMask = smoothstep(irisRadius, irisRadius + 0.1, length(uv) * 1.2);
                    color = mix(color, vec3(0.0), irisMask * (1.0 - u_iris));

                    // Focus rack simulation
                    float dofBlur = abs(length(uv) - u_focus * 0.5);
                    vec3 blurredColor = mix(color, vec3(dot(color, vec3(0.3, 0.5, 0.2))), dofBlur * 0.3);
                    color = mix(color, blurredColor, (1.0 - u_focus) * 0.4);

                    // Exposure
                    color *= u_exposure * 2.5 + 0.3;

                    // Shutter snap (micro strobe + chromatic split)
                    color += u_shutter * vec3(1.0, 0.98, 0.95) * 0.5;

                    // Vignette
                    float vignette = 1.0 - pow(length(uv) * u_vignette, 2.5);
                    color *= vignette;

                    // Chromatic aberration
                    color = chromaticAberration(uv, color, u_chromatic);

                    // Film grain
                    color += filmGrain(screenUV, time, u_grain);

                    // Tone mapping
                    color = color / (color + vec3(1.0));
                    color = pow(color, vec3(1.0 / 2.2));

                    gl_FragColor = vec4(color, 1.0);
                }
            `;

            function compile(src, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.warn('Shader:', gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            const vs = compile(vertexShader, gl.VERTEX_SHADER);
            const fs = compile(fragmentShader, gl.FRAGMENT_SHADER);
            if (!vs || !fs) return;

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            // Standard uniforms
            const posLoc = gl.getAttribLocation(program, 'position');
            const resLoc = gl.getUniformLocation(program, 'resolution');
            const timeLoc = gl.getUniformLocation(program, 'time');
            const mouseLoc = gl.getUniformLocation(program, 'mouse');

            // Camera uniforms
            const irisLoc = gl.getUniformLocation(program, 'u_iris');
            const focusLoc = gl.getUniformLocation(program, 'u_focus');
            const exposureLoc = gl.getUniformLocation(program, 'u_exposure');
            const vignetteLoc = gl.getUniformLocation(program, 'u_vignette');
            const grainLoc = gl.getUniformLocation(program, 'u_grain');
            const chromaticLoc = gl.getUniformLocation(program, 'u_chromatic');
            const shutterLoc = gl.getUniformLocation(program, 'u_shutter');
            const breathingLoc = gl.getUniformLocation(program, 'u_breathing');

            // Material & seal uniforms
            const materialityLoc = gl.getUniformLocation(program, 'u_materiality');
            const sealLoc = gl.getUniformLocation(program, 'u_seal');
            const seedLoc = gl.getUniformLocation(program, 'u_seed');

            let mouseX = 0.5, mouseY = 0.5;
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX / window.innerWidth;
                mouseY = 1.0 - (e.clientY / window.innerHeight);
            }, { passive: true });

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resize();
            window.addEventListener('resize', resize, { passive: true });

            function render(time) {
                const cam = window.RitualCamera;

                gl.useProgram(program);
                gl.uniform2f(resLoc, canvas.width, canvas.height);
                gl.uniform1f(timeLoc, time * 0.001);
                gl.uniform2f(mouseLoc, mouseX, mouseY);

                // Camera language
                gl.uniform1f(irisLoc, cam.iris);
                gl.uniform1f(focusLoc, cam.focus);
                gl.uniform1f(exposureLoc, cam.exposure);
                gl.uniform1f(vignetteLoc, cam.vignette);
                gl.uniform1f(grainLoc, cam.grain);
                gl.uniform1f(chromaticLoc, cam.chromatic);
                gl.uniform1f(shutterLoc, cam.shutterSnap);
                gl.uniform1f(breathingLoc, cam.lensBreathing);

                // Material & seal
                gl.uniform1f(materialityLoc, cam.materiality);
                gl.uniform1f(sealLoc, cam.sealProgress);
                gl.uniform1f(seedLoc, 0.42);

                // Decay shutter snap
                cam.shutterSnap *= 0.85;
                if (cam.shutterSnap < 0.01) cam.shutterSnap = 0;

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        })();
    </script>

    <!-- ENHANCED 3D CONSCIOUSNESS FIELD - PURE WEBGL, ZERO DEPENDENCIES -->
    <script>
        (function() {
            const shouldRun = !isMobile;
            if (!shouldRun) return;

            const container = document.getElementById('consciousness3D');
            if (!container) return;

            const canvas = document.createElement('canvas');
            container.appendChild(canvas);
            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            if (!gl) return;

            // Enhanced vertex shader with 3D particle simulation
            const vertexShader = `
                attribute vec2 position;
                varying vec2 vUv;
                void main() {
                    vUv = position * 0.5 + 0.5;
                    gl_Position = vec4(position, 0.0, 1.0);
                }
            `;

            // Advanced fragment shader with 3D particle field, depth, and bloom
            const fragmentShader = `
                precision highp float;
                uniform vec2 resolution;
                uniform float time;
                uniform vec2 mouse;
                varying vec2 vUv;

                // Hash functions for particle generation
                float hash(float n) { return fract(sin(n) * 43758.5453123); }
                vec2 hash2(vec2 p) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }
                vec3 hash3(float n) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423)); }

                // Simplex noise
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
                    vec2 i = floor(v + dot(v, C.yy));
                    vec2 x0 = v - i + dot(i, C.xx);
                    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i);
                    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                    m = m*m; m = m*m;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                    vec3 g;
                    g.x = a0.x * x0.x + h.x * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                // 3D particle field simulation
                vec3 getParticlePosition(float id, float t) {
                    vec3 seed = hash3(id);
                    float angle = seed.x * 6.28318530718 + t * 0.08;
                    float radius = 2.8 + seed.y * 3.8;
                    float height = (seed.z - 0.5) * 2.2;

                    // Rotating toroidal flow
                    float x = cos(angle) * radius;
                    float z = sin(angle) * radius;
                    float y = height + sin((x + t) * 0.1) * 0.7 + cos((z + t) * 0.07) * 0.7;

                    return vec3(x, y, z);
                }

                // Ray-sphere intersection for particles
                float particleSDF(vec3 rayPos, vec3 particlePos, float size) {
                    return length(rayPos - particlePos) - size;
                }

                // Bloom effect
                vec3 bloom(vec2 uv, vec3 color, float intensity) {
                    vec3 bloom = vec3(0.0);
                    float steps = 8.0;
                    for(float i = 1.0; i <= steps; i++) {
                        float scale = 1.0 + (i / steps) * 0.03;
                        vec2 offset = (uv - 0.5) * (scale - 1.0);
                        bloom += color * (1.0 / (i * 1.5));
                    }
                    return bloom * intensity;
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy) / resolution;
                    vec2 p = (gl_FragCoord.xy - 0.5 * resolution) / min(resolution.x, resolution.y);

                    // Mouse parallax for camera
                    vec2 mouseInfluence = (mouse - 0.5) * 0.4;
                    p += mouseInfluence * 0.15;

                    float t = time * 1.2;

                    // Ray setup for 3D rendering
                    vec3 rayOrigin = vec3(mouseInfluence.x * 2.0, 0.8 - mouseInfluence.y * 1.2, 5.5);
                    vec3 rayDir = normalize(vec3(p.x, p.y, -2.0));

                    // Particle field rendering
                    vec3 finalColor = vec3(0.0);
                    float particleCount = 120.0; // Optimized count for pure shader
                    float totalGlow = 0.0;

                    for(float i = 0.0; i < particleCount; i++) {
                        vec3 particlePos = getParticlePosition(i, t);

                        // March the ray
                        float maxDist = 20.0;
                        float marchDist = 0.0;
                        float minDist = maxDist;

                        for(int step = 0; step < 32; step++) {
                            vec3 rayPos = rayOrigin + rayDir * marchDist;
                            float dist = particleSDF(rayPos, particlePos, 0.012);
                            minDist = min(minDist, dist);

                            if(dist < 0.01 || marchDist > maxDist) break;
                            marchDist += dist * 0.5;
                        }

                        // Particle color variation
                        vec3 seed = hash3(i);
                        vec3 goldShadow = vec3(0.54, 0.45, 0.21);
                        vec3 gold = vec3(0.83, 0.69, 0.22);
                        vec3 goldBright = vec3(1.0, 0.84, 0.0);
                        vec3 amber = vec3(1.0, 0.75, 0.0);

                        vec3 particleColor = seed.x < 0.25 ? goldShadow :
                                           seed.x < 0.7 ? gold :
                                           seed.x < 0.9 ? goldBright : amber;

                        // Glow calculation
                        float glow = 0.008 / (minDist + 0.001);
                        glow = pow(glow, 1.5) * 0.5;

                        // Depth fade
                        float depth = 1.0 - (length(particlePos - rayOrigin) / 12.0);
                        depth = max(0.0, depth);

                        finalColor += particleColor * glow * depth;
                        totalGlow += glow * depth;
                    }

                    // Additive blending simulation
                    finalColor = clamp(finalColor, 0.0, 1.0);

                    // Bloom pass
                    vec3 bloomColor = bloom(uv, finalColor, 0.65);
                    finalColor += bloomColor * 0.45;

                    // Atmospheric fog
                    float fog = exp(-length(p) * 0.3);
                    finalColor *= fog;

                    // Subtle vignette
                    float vignette = 1.0 - length(p - vec2(0.0)) * 0.2;
                    finalColor *= vignette;

                    // Tone mapping (ACES-like)
                    finalColor = finalColor / (finalColor + vec3(1.0));
                    finalColor = pow(finalColor, vec3(1.0 / 2.2)); // Gamma correction
                    finalColor *= 0.85; // Exposure

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            function compile(src, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            const vs = compile(vertexShader, gl.VERTEX_SHADER);
            const fs = compile(fragmentShader, gl.FRAGMENT_SHADER);
            if (!vs || !fs) return;

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return;
            }

            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const posLoc = gl.getAttribLocation(program, 'position');
            const resLoc = gl.getUniformLocation(program, 'resolution');
            const timeLoc = gl.getUniformLocation(program, 'time');
            const mouseLoc = gl.getUniformLocation(program, 'mouse');

            let mouseX = 0.5, mouseY = 0.5;
            let targetMouseX = 0.5, targetMouseY = 0.5;

            document.addEventListener('mousemove', (e) => {
                targetMouseX = e.clientX / window.innerWidth;
                targetMouseY = 1.0 - (e.clientY / window.innerHeight);
            }, { passive: true });

            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            resize();
            window.addEventListener('resize', resize, { passive: true });

            let startTime = Date.now();
            let frameCount = 0;

            function render() {
                frameCount++;
                // Render every other frame for performance
                if (frameCount % 2 === 0) {
                    const currentTime = (Date.now() - startTime) * 0.001;

                    // Smooth mouse interpolation
                    mouseX += (targetMouseX - mouseX) * 0.05;
                    mouseY += (targetMouseY - mouseY) * 0.05;

                    gl.useProgram(program);
                    gl.uniform2f(resLoc, canvas.width, canvas.height);
                    gl.uniform1f(timeLoc, currentTime);
                    gl.uniform2f(mouseLoc, mouseX, mouseY);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.enableVertexAttribArray(posLoc);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                }
                requestAnimationFrame(render);
            }
            render();
        })();
    </script>

    <!-- ════════════════════════════════════════════════════════════════════════════
         PARADIGM SHIFT: THE PROOF BECOMES THE INTERFACE

         This is CytherAI's product thesis, embodied:
         Verifiable + Deterministic + Sovereign

         Every visual effect is now a projection of proof state.
    ════════════════════════════════════════════════════════════════════════════ -->
    <script>
    (function() {
        'use strict';

        // ════════════════════════════════════════
        // EVENT BUS - The Nervous System
        // ════════════════════════════════════════
        const ProofBus = {
            listeners: {},

            on(event, callback) {
                if (!this.listeners[event]) this.listeners[event] = [];
                this.listeners[event].push(callback);
                return () => this.off(event, callback);
            },

            off(event, callback) {
                if (!this.listeners[event]) return;
                this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
            },

            emit(event, data) {
                if (!this.listeners[event]) return;
                this.listeners[event].forEach(cb => cb(data));
            }
        };

        // ════════════════════════════════════════
        // GLOBAL PROOF STATE
        // All visuals read from this state
        // ════════════════════════════════════════
        const ProofState = {
            phase: 'idle',           // idle | initiation | convergence | lock | hold
            entropy: 0.0,            // 0.0 → 1.0 (high=chaotic, low=ordered)
            coherence: 0.0,          // 0.0 → 1.0 (how close to closure)
            materiality: 0.0,        // 0.0 → 1.0 (ethereal → crisp/physical)
            seed: 0xCYTHER,          // fixed deterministic seed
            witnessHash: null,       // receipt hash → deterministic seed
            ruleVector: [],          // distribution of axioms/rules used
            stepIndex: 0,            // current step in proof
            totalSteps: 0,           // total steps in proof
            currentReceipt: null,    // full receipt object
            lastProofTree: null,     // for replay

            setPhase(phase) {
                this.phase = phase;
                document.body.setAttribute('data-proof-phase', phase);
                ProofBus.emit('phase:change', phase);
            },

            update(updates) {
                Object.assign(this, updates);
                ProofBus.emit('state:update', this);
                ProofBus.emit('ritual:dial', {
                    entropy: this.entropy,
                    coherence: this.coherence,
                    materiality: this.materiality,
                    seed: this.seed
                });
            }
        };

        // ════════════════════════════════════════
        // PROOF KERNEL - Deterministic Logic Prover
        // Propositional logic with natural deduction
        // ════════════════════════════════════════
        const ProofKernel = {
            // Inference rules
            rules: {
                'ASSUME': { name: 'Assumption', symbol: 'ASM' },
                'MP': { name: 'Modus Ponens', symbol: '→E' },
                'AND_INTRO': { name: '∧-Introduction', symbol: '∧I' },
                'AND_ELIM_L': { name: '∧-Elimination (L)', symbol: '∧E₁' },
                'AND_ELIM_R': { name: '∧-Elimination (R)', symbol: '∧E₂' },
                'OR_INTRO_L': { name: '∨-Introduction (L)', symbol: '∨I₁' },
                'OR_INTRO_R': { name: '∨-Introduction (R)', symbol: '∨I₂' },
                'IMPL_INTRO': { name: '→-Introduction', symbol: '→I' },
                'DNE': { name: 'Double Negation Elim', symbol: '¬¬E' },
                'CONTRA': { name: 'Contraposition', symbol: 'CONTRA' },
                'QED': { name: 'Proof Complete', symbol: '∎' }
            },

            // Parse a logical formula into AST
            parse(formula) {
                formula = formula.trim();

                // Handle outermost parentheses
                if (formula.startsWith('(') && this.findMatchingParen(formula, 0) === formula.length - 1) {
                    formula = formula.slice(1, -1);
                }

                // Find main connective (lowest precedence, rightmost for left-associativity)
                let depth = 0;
                let mainOp = null;
                let mainOpIdx = -1;
                const ops = ['→', '↔', '∨', '∧'];

                for (let i = formula.length - 1; i >= 0; i--) {
                    const ch = formula[i];
                    if (ch === ')') depth++;
                    else if (ch === '(') depth--;
                    else if (depth === 0) {
                        for (const op of ops) {
                            if (formula.substring(i, i + op.length) === op) {
                                if (mainOp === null || ops.indexOf(op) <= ops.indexOf(mainOp)) {
                                    mainOp = op;
                                    mainOpIdx = i;
                                }
                            }
                        }
                    }
                }

                if (mainOp && mainOpIdx > 0) {
                    return {
                        type: mainOp,
                        left: this.parse(formula.substring(0, mainOpIdx).trim()),
                        right: this.parse(formula.substring(mainOpIdx + mainOp.length).trim())
                    };
                }

                // Negation
                if (formula.startsWith('¬')) {
                    return { type: '¬', operand: this.parse(formula.substring(1).trim()) };
                }

                // Atomic proposition
                return { type: 'atom', value: formula };
            },

            findMatchingParen(str, start) {
                let depth = 1;
                for (let i = start + 1; i < str.length; i++) {
                    if (str[i] === '(') depth++;
                    else if (str[i] === ')') {
                        depth--;
                        if (depth === 0) return i;
                    }
                }
                return -1;
            },

            // Convert AST back to string
            stringify(ast) {
                if (!ast) return '';
                if (ast.type === 'atom') return ast.value;
                if (ast.type === '¬') return '¬' + this.stringify(ast.operand);
                return `(${this.stringify(ast.left)} ${ast.type} ${this.stringify(ast.right)})`;
            },

            // Check structural equality
            equals(a, b) {
                if (!a || !b) return false;
                if (a.type !== b.type) return false;
                if (a.type === 'atom') return a.value === b.value;
                if (a.type === '¬') return this.equals(a.operand, b.operand);
                return this.equals(a.left, b.left) && this.equals(a.right, b.right);
            },

            // Deterministic proof search with seeded randomness
            prove(claim, seed = Date.now()) {
                const ast = this.parse(claim);
                const steps = [];
                const rulesUsed = new Set();
                let stepId = 0;

                // Seeded random for deterministic behavior
                const seededRandom = (function(s) {
                    return function() {
                        s = Math.sin(s) * 10000;
                        return s - Math.floor(s);
                    };
                })(seed);

                // Try to prove the claim
                const proved = this.search(ast, [], steps, rulesUsed, seededRandom, 0);

                if (proved) {
                    steps.push({
                        id: steps.length,
                        rule: 'QED',
                        formula: this.stringify(ast),
                        justification: 'Proof complete',
                        depth: 0
                    });
                    rulesUsed.add('QED');
                }

                return {
                    success: proved,
                    steps,
                    rulesUsed: Array.from(rulesUsed),
                    tree: this.buildTree(steps),
                    claim,
                    seed
                };
            },

            // Recursive proof search
            search(goal, assumptions, steps, rulesUsed, rand, depth) {
                if (depth > 20) return false; // Prevent infinite recursion

                // Check if goal is already assumed
                for (const asm of assumptions) {
                    if (this.equals(asm.ast, goal)) {
                        return true;
                    }
                }

                // Strategy based on goal structure
                if (goal.type === '→') {
                    // →-Introduction: assume antecedent, prove consequent
                    const newAsm = { ast: goal.left, id: steps.length };
                    steps.push({
                        id: steps.length,
                        rule: 'ASSUME',
                        formula: this.stringify(goal.left),
                        justification: 'Assumption for →-Introduction',
                        depth: depth + 1
                    });
                    rulesUsed.add('ASSUME');

                    const subProof = this.search(goal.right, [...assumptions, newAsm], steps, rulesUsed, rand, depth + 1);

                    if (subProof) {
                        steps.push({
                            id: steps.length,
                            rule: 'IMPL_INTRO',
                            formula: this.stringify(goal),
                            justification: `→-Introduction [${newAsm.id}]`,
                            depth
                        });
                        rulesUsed.add('IMPL_INTRO');
                        return true;
                    }
                }

                if (goal.type === '∧') {
                    // ∧-Introduction: prove both sides
                    const leftProved = this.search(goal.left, assumptions, steps, rulesUsed, rand, depth + 1);
                    const rightProved = leftProved && this.search(goal.right, assumptions, steps, rulesUsed, rand, depth + 1);

                    if (leftProved && rightProved) {
                        steps.push({
                            id: steps.length,
                            rule: 'AND_INTRO',
                            formula: this.stringify(goal),
                            justification: '∧-Introduction',
                            depth
                        });
                        rulesUsed.add('AND_INTRO');
                        return true;
                    }
                }

                if (goal.type === '∨') {
                    // ∨-Introduction: try to prove either side
                    if (this.search(goal.left, assumptions, steps, rulesUsed, rand, depth + 1)) {
                        steps.push({
                            id: steps.length,
                            rule: 'OR_INTRO_L',
                            formula: this.stringify(goal),
                            justification: '∨-Introduction (L)',
                            depth
                        });
                        rulesUsed.add('OR_INTRO_L');
                        return true;
                    }
                }

                // Try ∧-Elimination on assumptions
                for (const asm of assumptions) {
                    if (asm.ast.type === '∧') {
                        if (this.equals(asm.ast.left, goal)) {
                            steps.push({
                                id: steps.length,
                                rule: 'AND_ELIM_L',
                                formula: this.stringify(goal),
                                justification: `∧-Elimination (L) from [${asm.id}]`,
                                depth
                            });
                            rulesUsed.add('AND_ELIM_L');
                            return true;
                        }
                        if (this.equals(asm.ast.right, goal)) {
                            steps.push({
                                id: steps.length,
                                rule: 'AND_ELIM_R',
                                formula: this.stringify(goal),
                                justification: `∧-Elimination (R) from [${asm.id}]`,
                                depth
                            });
                            rulesUsed.add('AND_ELIM_R');
                            return true;
                        }
                    }
                }

                // Try Modus Ponens
                for (const asm of assumptions) {
                    if (asm.ast.type === '→' && this.equals(asm.ast.right, goal)) {
                        // Try to prove the antecedent
                        if (this.search(asm.ast.left, assumptions, steps, rulesUsed, rand, depth + 1)) {
                            steps.push({
                                id: steps.length,
                                rule: 'MP',
                                formula: this.stringify(goal),
                                justification: `Modus Ponens from [${asm.id}]`,
                                depth
                            });
                            rulesUsed.add('MP');
                            return true;
                        }
                    }
                }

                // Double Negation Elimination
                if (goal.type === 'atom' || goal.type === '¬') {
                    const doubleNeg = { type: '¬', operand: { type: '¬', operand: goal } };
                    for (const asm of assumptions) {
                        if (this.equals(asm.ast, doubleNeg)) {
                            steps.push({
                                id: steps.length,
                                rule: 'DNE',
                                formula: this.stringify(goal),
                                justification: `Double Negation Elimination from [${asm.id}]`,
                                depth
                            });
                            rulesUsed.add('DNE');
                            return true;
                        }
                    }
                }

                return false;
            },

            // Build tree structure from steps
            buildTree(steps) {
                return {
                    nodes: steps.map(s => ({
                        id: s.id,
                        label: s.formula,
                        rule: s.rule,
                        depth: s.depth
                    })),
                    edges: steps.slice(1).map((s, i) => ({
                        from: Math.max(0, s.id - 1),
                        to: s.id
                    }))
                };
            }
        };

        // ════════════════════════════════════════
        // RECEIPT SYSTEM - Cryptographic Witness
        // SHA-256 hash for verifiability
        // ════════════════════════════════════════
        const ReceiptSystem = {
            async createReceipt(proofResult) {
                const timestamp = new Date().toISOString();
                const canonical = JSON.stringify({
                    claim: proofResult.claim,
                    success: proofResult.success,
                    steps: proofResult.steps,
                    rulesUsed: proofResult.rulesUsed,
                    seed: proofResult.seed,
                    timestamp
                });

                const hash = await this.sha256(canonical);

                return {
                    claim: proofResult.claim,
                    success: proofResult.success,
                    stepCount: proofResult.steps.length,
                    rulesUsed: proofResult.rulesUsed,
                    seed: proofResult.seed,
                    timestamp,
                    hash,
                    canonical,
                    tree: proofResult.tree
                };
            },

            async sha256(message) {
                const msgBuffer = new TextEncoder().encode(message);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            },

            async verify(receipt) {
                const recomputed = await this.sha256(receipt.canonical);
                return recomputed === receipt.hash;
            },

            download(receipt) {
                const blob = new Blob([JSON.stringify(receipt, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `proof-receipt-${receipt.hash.substring(0, 8)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        };

        // ════════════════════════════════════════
        // WITNESS CRYSTAL - 3D Verification Object
        // Facets derived from proof structure
        // ════════════════════════════════════════
        const WitnessCrystal = {
            container: null,
            crystal: null,
            core: null,
            facets: [],

            init() {
                this.container = document.getElementById('witnessCrystalContainer');
                this.crystal = document.getElementById('witnessCrystal');
                this.core = document.getElementById('crystalCore');
            },

            generate(receipt) {
                if (!this.crystal) return;

                // Clear existing facets
                this.facets.forEach(f => f.remove());
                this.facets = [];

                // Generate facets based on proof structure
                const stepCount = receipt.stepCount;
                const hashSeed = parseInt(receipt.hash.substring(0, 8), 16);

                for (let i = 0; i < Math.min(stepCount, 12); i++) {
                    const facet = document.createElement('div');
                    facet.className = 'crystal-facet';

                    const angle = (i / stepCount) * 360 + (hashSeed % 60);
                    const radius = 80 + (i % 3) * 30;
                    const size = 40 + (hashSeed % 20);
                    const zOffset = (i - stepCount / 2) * 15;

                    facet.style.width = size + 'px';
                    facet.style.height = size + 'px';
                    facet.style.left = `calc(50% - ${size/2}px + ${Math.cos(angle * Math.PI / 180) * radius}px)`;
                    facet.style.top = `calc(50% - ${size/2}px + ${Math.sin(angle * Math.PI / 180) * radius}px)`;
                    facet.style.transform = `rotateX(${45 + (hashSeed % 30)}deg) rotateY(${angle}deg) translateZ(${zOffset}px)`;
                    facet.dataset.stepIndex = i;

                    this.crystal.appendChild(facet);
                    this.facets.push(facet);
                }

                // Set crystal orientation from hash
                const rotation = (hashSeed % 360);
                this.crystal.style.setProperty('--crystal-rotation', rotation + 'deg');
            },

            showFacet(index) {
                if (this.facets[index]) {
                    this.facets[index].classList.add('visible');
                }
            },

            verify() {
                this.facets.forEach(f => f.classList.add('verified'));
                this.crystal.classList.add('locked');
                this.core.classList.add('verified');
            },

            activate() {
                this.container.classList.add('active');
                this.core.classList.add('active');
            },

            reset() {
                this.container.classList.remove('active');
                this.crystal.classList.remove('locked');
                this.core.classList.remove('active', 'verified');
                this.facets.forEach(f => f.remove());
                this.facets = [];
            }
        };

        // ════════════════════════════════════════
        // CROWN ANIMATION SYNC
        // Crown builds with proof steps
        // ════════════════════════════════════════
        const CrownSync = {
            elements: {},

            init() {
                this.elements = {
                    peakCenter: document.querySelector('.crown-peak-center'),
                    peakLeft: document.querySelector('.crown-peak-left'),
                    peakRight: document.querySelector('.crown-peak-right'),
                    arc: document.querySelector('.crown-arc'),
                    terminalLeft: document.querySelector('.crown-terminal-left'),
                    terminalRight: document.querySelector('.crown-terminal-right'),
                    jewelCenter: document.querySelector('.crown-jewel-center'),
                    jewelLeft: document.querySelector('.crown-jewel-left'),
                    jewelRight: document.querySelector('.crown-jewel-right'),
                    lambda: document.querySelector('.lambda-symbol'),
                    verification: document.querySelector('.verification-mark')
                };
            },

            reset() {
                Object.values(this.elements).forEach(el => {
                    if (el) {
                        el.style.animation = 'none';
                        el.style.opacity = '0';
                    }
                });
            },

            animateStep(stepIndex, totalSteps) {
                const progress = stepIndex / totalSteps;
                const elementOrder = [
                    'peakCenter', 'peakLeft', 'peakRight', 'arc',
                    'terminalLeft', 'terminalRight', 'jewelCenter',
                    'jewelLeft', 'jewelRight', 'lambda', 'verification'
                ];

                const targetIndex = Math.floor(progress * elementOrder.length);

                for (let i = 0; i <= targetIndex && i < elementOrder.length; i++) {
                    const key = elementOrder[i];
                    const el = this.elements[key];
                    if (el) {
                        el.style.animation = 'proveIn 0.6s var(--ease-out-expo) forwards';
                        el.style.opacity = '1';
                    }
                }
            },

            complete() {
                Object.values(this.elements).forEach(el => {
                    if (el) {
                        el.style.animation = 'proveIn 0.6s var(--ease-out-expo) forwards';
                        el.style.opacity = '1';
                    }
                });

                // Flash the verification mark
                if (this.elements.verification) {
                    this.elements.verification.style.opacity = '0.8';
                    this.elements.verification.style.filter = 'drop-shadow(0 0 10px var(--gold-core))';
                }
            }
        };

        // ════════════════════════════════════════
        // CAUSAL TRACE SYSTEM
        // Particles that show proof causality
        // ════════════════════════════════════════
        const CausalTraces = {
            container: null,
            traces: [],

            init() {
                this.container = document.getElementById('consciousnessParticles');
            },

            emit(x, y, diverging = false) {
                if (!this.container) return;

                const trace = document.createElement('div');
                trace.className = 'causal-trace active';
                trace.style.left = x + 'px';
                trace.style.top = y + 'px';

                if (diverging) {
                    const dx = (Math.random() - 0.5) * 200;
                    const dy = (Math.random() - 0.5) * 200;
                    trace.style.setProperty('--trace-dx', dx + 'px');
                    trace.style.setProperty('--trace-dy', dy + 'px');
                    trace.classList.add('diverging');
                } else {
                    trace.classList.add('converging');
                    trace.style.setProperty('--target-x', (window.innerWidth / 2 - x) + 'px');
                    trace.style.setProperty('--target-y', (window.innerHeight / 2 - y) + 'px');
                }

                this.container.appendChild(trace);
                this.traces.push(trace);

                // Clean up after animation
                setTimeout(() => {
                    trace.remove();
                    this.traces = this.traces.filter(t => t !== trace);
                }, 2000);
            },

            burst(count = 10) {
                for (let i = 0; i < count; i++) {
                    const x = window.innerWidth / 2 + (Math.random() - 0.5) * 300;
                    const y = window.innerHeight / 2 + (Math.random() - 0.5) * 300;
                    setTimeout(() => this.emit(x, y, true), i * 50);
                }
            },

            converge(count = 10) {
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    setTimeout(() => this.emit(x, y, false), i * 100);
                }
            }
        };

        // ════════════════════════════════════════
        // SEMANTIC LENS CURSOR
        // Hover reveals proof subgraph
        // ════════════════════════════════════════
        const SemanticLens = {
            info: null,
            currentStep: null,

            init() {
                this.info = document.getElementById('cursorLensInfo');
            },

            show(step, x, y) {
                if (!this.info || !step) return;

                this.info.querySelector('.lens-rule').textContent =
                    ProofKernel.rules[step.rule]?.name || step.rule;
                this.info.querySelector('.lens-step').textContent =
                    step.justification;

                this.info.style.left = (x + 20) + 'px';
                this.info.style.top = (y - 10) + 'px';
                this.info.classList.add('visible');
                this.currentStep = step;
            },

            hide() {
                if (this.info) {
                    this.info.classList.remove('visible');
                    this.currentStep = null;
                }
            }
        };

        // ════════════════════════════════════════
        // UI CONTROLLER
        // Orchestrates the proof experience
        // ════════════════════════════════════════
        const ProofUI = {
            elements: {},
            isProving: false,

            init() {
                this.elements = {
                    input: document.getElementById('claimInput'),
                    proveBtn: document.getElementById('proveBtn'),
                    replayBtn: document.getElementById('replayBtn'),
                    container: document.getElementById('proofInputContainer'),
                    receipt: document.getElementById('proofReceipt'),
                    receiptClaim: document.getElementById('receiptClaim'),
                    receiptSteps: document.getElementById('receiptSteps'),
                    receiptRules: document.getElementById('receiptRules'),
                    receiptTimestamp: document.getElementById('receiptTimestamp'),
                    receiptHash: document.getElementById('receiptHash'),
                    copyBtn: document.getElementById('copyReceiptBtn'),
                    downloadBtn: document.getElementById('downloadReceiptBtn'),
                    verifyBtn: document.getElementById('verifyReceiptBtn'),
                    flash: document.getElementById('verificationFlash')
                };

                this.bindEvents();
            },

            bindEvents() {
                // Preset buttons
                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.elements.input.value = btn.dataset.claim;
                        this.elements.input.focus();
                    });
                });

                // Prove button
                this.elements.proveBtn.addEventListener('click', () => this.prove());

                // Replay button
                this.elements.replayBtn.addEventListener('click', () => this.replay());

                // Receipt buttons
                this.elements.copyBtn.addEventListener('click', () => this.copyHash());
                this.elements.downloadBtn.addEventListener('click', () => this.download());
                this.elements.verifyBtn.addEventListener('click', () => this.verify());

                // Enter key
                this.elements.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.prove();
                });
            },

            async prove() {
                if (this.isProving) return;

                const claim = this.elements.input.value.trim();
                if (!claim) {
                    this.elements.input.focus();
                    return;
                }

                this.isProving = true;
                this.elements.proveBtn.disabled = true;
                this.elements.proveBtn.setAttribute('data-proving', 'true');
                this.elements.receipt.classList.remove('visible');

                // Reset state
                ProofState.setPhase('search');
                ProofState.update({ entropy: 0.8, coherence: 0.2, stepIndex: 0 });
                CrownSync.reset();
                WitnessCrystal.reset();
                CausalTraces.burst(15);

                // Run the proof
                const seed = Date.now();
                const result = ProofKernel.prove(claim, seed);

                // Animate through steps
                for (let i = 0; i < result.steps.length; i++) {
                    await this.delay(300 + Math.random() * 200);

                    ProofState.update({
                        stepIndex: i,
                        totalSteps: result.steps.length,
                        entropy: Math.max(0.2, 0.8 - (i / result.steps.length) * 0.6),
                        coherence: (i / result.steps.length) * 0.8
                    });

                    CrownSync.animateStep(i, result.steps.length);
                    ProofBus.emit('proof:step', { step: result.steps[i], index: i });

                    // Emit causal trace
                    const x = window.innerWidth / 2 + (Math.random() - 0.5) * 200;
                    const y = window.innerHeight / 2 + (Math.random() - 0.5) * 200;
                    CausalTraces.emit(x, y, i < result.steps.length / 2);
                }

                if (result.success) {
                    // Converge phase
                    ProofState.setPhase('converge');
                    ProofState.update({ entropy: 0.1, coherence: 0.9 });
                    CausalTraces.converge(10);

                    await this.delay(800);

                    // Create receipt
                    const receipt = await ReceiptSystem.createReceipt(result);
                    ProofState.update({
                        witnessHash: receipt.hash,
                        ruleVector: result.rulesUsed,
                        currentReceipt: receipt,
                        lastProofTree: result.tree
                    });

                    // Crystallize
                    ProofState.setPhase('crystallize');
                    ProofState.update({ entropy: 0, coherence: 1 });

                    // Generate and show crystal
                    WitnessCrystal.generate(receipt);
                    WitnessCrystal.activate();

                    // Reveal facets one by one
                    for (let i = 0; i < receipt.stepCount && i < 12; i++) {
                        await this.delay(100);
                        WitnessCrystal.showFacet(i);
                    }

                    WitnessCrystal.verify();
                    CrownSync.complete();

                    // Verification flash
                    this.elements.flash.classList.add('active');
                    setTimeout(() => this.elements.flash.classList.remove('active'), 1000);

                    // Update receipt display
                    this.showReceipt(receipt);

                    // Enable replay
                    this.elements.replayBtn.classList.add('available');

                    // Set proof rotation for geometry
                    const rotation = parseInt(receipt.hash.substring(0, 8), 16) % 360;
                    document.body.style.setProperty('--proof-rotation', rotation + 'deg');

                    ProofBus.emit('proof:complete', receipt);
                } else {
                    ProofState.setPhase('idle');
                    ProofState.update({ entropy: 0.5, coherence: 0 });
                    ProofBus.emit('proof:fail', { claim });
                }

                this.isProving = false;
                this.elements.proveBtn.disabled = false;
                this.elements.proveBtn.removeAttribute('data-proving');
            },

            async replay() {
                const receipt = ProofState.currentReceipt;
                if (!receipt) return;

                // Re-run with same seed for deterministic replay
                this.elements.input.value = receipt.claim;

                this.isProving = false;
                this.elements.replayBtn.classList.remove('available');

                await this.prove();
            },

            showReceipt(receipt) {
                this.elements.receiptClaim.textContent = receipt.claim;
                this.elements.receiptSteps.textContent = receipt.stepCount;
                this.elements.receiptRules.textContent = receipt.rulesUsed.join(', ');
                this.elements.receiptTimestamp.textContent = new Date(receipt.timestamp).toLocaleString();
                this.elements.receiptHash.textContent = receipt.hash;
                this.elements.receipt.classList.add('visible');
            },

            async copyHash() {
                const receipt = ProofState.currentReceipt;
                if (!receipt) return;

                await navigator.clipboard.writeText(receipt.hash);
                this.elements.copyBtn.textContent = 'COPIED!';
                setTimeout(() => {
                    this.elements.copyBtn.textContent = 'COPY HASH';
                }, 2000);
            },

            download() {
                const receipt = ProofState.currentReceipt;
                if (!receipt) return;
                ReceiptSystem.download(receipt);
            },

            async verify() {
                const receipt = ProofState.currentReceipt;
                if (!receipt) return;

                const valid = await ReceiptSystem.verify(receipt);
                this.elements.verifyBtn.textContent = valid ? '✓ VALID' : '✗ INVALID';
                this.elements.verifyBtn.style.color = valid ? 'var(--gold-bright)' : 'var(--danger)';

                setTimeout(() => {
                    this.elements.verifyBtn.textContent = 'VERIFY';
                    this.elements.verifyBtn.style.color = '';
                }, 2000);
            },

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };

        // ════════════════════════════════════════
        // SHADER STATE BINDING
        // Drive visuals from global dials (entropy, coherence, materiality, seed)
        // ════════════════════════════════════════
        const ShaderBinding = {
            init() {
                ProofBus.on('state:update', (state) => {
                    const entropy = state.entropy || 0;
                    const coherence = state.coherence || 0;
                    const materiality = state.materiality || 0;

                    // Shader field: driven by entropy + materiality
                    // Turbulence decreases as entropy falls, edges sharpen as materiality rises
                    const shader = document.getElementById('consciousnessShader');
                    if (shader) {
                        const intensity = 0.15 + (coherence * 0.25) + (materiality * 0.15);
                        shader.style.opacity = intensity;
                        shader.style.filter = `contrast(${1 + materiality * 0.3})`;
                    }

                    // Neural field: higher entropy = more visible activity
                    const neuralField = document.getElementById('neuralField');
                    if (neuralField) {
                        neuralField.style.opacity = 0.05 + (entropy * 0.15);
                    }

                    // Quantum grid: fades with coherence
                    const quantumGrid = document.querySelector('.quantum-grid');
                    if (quantumGrid) {
                        quantumGrid.style.opacity = 0.01 + (entropy * 0.03);
                    }

                    // Crown/logo glow: intensifies with materiality
                    const logoGlow = document.querySelector('.logo-glow');
                    if (logoGlow) {
                        logoGlow.style.opacity = materiality * 0.8;
                    }

                    // Update sacred geometry based on coherence
                    const geometry = document.querySelector('.sacred-geometry');
                    if (geometry) {
                        // Rotation speed slows as coherence increases
                        const speedFactor = 1 - (coherence * 0.8);
                        if (speedFactor < 0.2) {
                            geometry.style.animationPlayState = 'paused';
                        }
                    }
                });

                // Listen for ritual dial changes
                ProofBus.on('ritual:dial', (dials) => {
                    // Set CSS custom properties for shader-driven effects
                    document.documentElement.style.setProperty('--dial-entropy', dials.entropy);
                    document.documentElement.style.setProperty('--dial-coherence', dials.coherence);
                    document.documentElement.style.setProperty('--dial-materiality', dials.materiality);
                });
            }
        };

        // ════════════════════════════════════════════════════════════════════════════
        // RITUAL CONTROLLER - NORTH STAR ARCHITECTURE
        // ════════════════════════════════════════════════════════════════════════════
        // The Irreversible Capture: Chaos → Convergence → Capture → Seal
        //
        // CORE PRINCIPLE: Single master progress scalar (0→1) drives EVERYTHING.
        // No independent dials. No arbitrary animations. Pure determinism.
        //
        // HIERARCHY:
        //   progress (0→1) → entropy, coherence → materiality → camera
        //
        // THE CAPTURE WINDOW: progress 0.78-0.82 (4% of runtime = the snap)
        // 95% restraint, 5% drama. Everything else serves the capture.
        // ════════════════════════════════════════════════════════════════════════════
        const RitualController = {
            // ─────────────────────────────────────────
            // MASTER STATE
            // ─────────────────────────────────────────
            progress: 0,              // 0→1: THE master scalar
            isRunning: false,
            isPaused: false,
            hasCompleted: false,
            isLocked: false,          // Once true, NEVER goes back

            // Total ritual duration (ms) - 16 seconds
            DURATION: 16000,

            // The Capture Window - where the snap happens
            // 95% restraint / 5% capture
            CAPTURE_START: 0.78,      // 12.48s
            CAPTURE_PEAK: 0.80,       // 12.80s - the shutter snap
            CAPTURE_END: 0.82,        // 13.12s

            // Lock point - no return after this
            LOCK_POINT: 0.85,

            // Stamp flash timing within capture
            stampShown: false,
            stampHidden: false,

            // NDA-safe micro-artifacts (fleeting, peripheral)
            microArtifacts: [
                'INIT: RANDOM SEED',
                'PIPELINE: TOKENIZER → WEIGHTS',
                'MODE: SOVEREIGN EXECUTION',
                'RIGOR: FROM FIRST PRINCIPLES'
            ],
            artifactIndex: 0,
            lastArtifactTime: 0,

            // The seal stamp (shown once at capture)
            stampLine: 'DETERMINISM SEALED.',

            elements: {},

            // ─────────────────────────────────────────
            // EASING FUNCTIONS
            // ─────────────────────────────────────────
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            },

            easeInOutQuart(t) {
                return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
            },

            easeOutExpo(t) {
                return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            },

            // ─────────────────────────────────────────
            // HIERARCHICAL DIAL DERIVATION
            // progress → entropy/coherence → materiality → camera
            // ─────────────────────────────────────────
            deriveState(progress) {
                // Clamp progress
                const p = Math.max(0, Math.min(1, progress));

                // Core dials - everything flows from progress
                const coherence = this.easeOutCubic(p);
                const entropy = 1 - coherence;
                const materiality = coherence * coherence;  // coherence² - lags behind

                // Seal progress - starts at 20%, completes at capture
                let sealProgress = 0;
                if (p > 0.15) {
                    const sealT = (p - 0.15) / (this.CAPTURE_PEAK - 0.15);
                    sealProgress = this.easeInOutQuart(Math.min(sealT, 1));
                }

                // Camera derives from coherence and capture window
                const inCaptureWindow = p >= this.CAPTURE_START && p <= this.CAPTURE_END;
                const captureIntensity = inCaptureWindow
                    ? Math.sin((p - this.CAPTURE_START) / (this.CAPTURE_END - this.CAPTURE_START) * Math.PI)
                    : 0;

                // Iris: opens as coherence rises
                const iris = this.easeOutExpo(Math.min(p * 1.5, 1));

                // Focus: racks from 0 → 1 following coherence
                const focus = coherence;

                // Exposure: low → medium, spike at capture
                const baseExposure = 0.15 + coherence * 0.4;
                const exposure = baseExposure + captureIntensity * 0.25;

                // Vignette: strong → subtle as coherence rises
                const vignette = 1.0 - coherence * 0.5;

                // Grain: loose → tight (restraint increases)
                const grain = 0.15 - coherence * 0.11;

                // Chromatic: only during capture window
                const chromatic = captureIntensity * 0.6;

                // Shutter snap: peak of capture window only
                const atPeak = Math.abs(p - this.CAPTURE_PEAK) < 0.01;
                const shutterSnap = atPeak ? 1.0 : 0;

                // Lens breathing: subtle, decreases as we lock
                const lensBreathing = (1 - coherence) * 0.4;

                return {
                    // Core state
                    entropy,
                    coherence,
                    materiality,

                    // Camera
                    iris,
                    focus,
                    exposure,
                    vignette,
                    grain,
                    chromatic,
                    shutterSnap,
                    lensBreathing,
                    sealProgress,

                    // Flags
                    inCaptureWindow,
                    captureIntensity
                };
            },

            // ─────────────────────────────────────────
            // APPLY STATE TO ALL SYSTEMS
            // ─────────────────────────────────────────
            applyState(state) {
                const cam = window.RitualCamera;

                // Update ProofState (for any listeners)
                ProofState.update({
                    entropy: state.entropy,
                    coherence: state.coherence,
                    materiality: state.materiality
                });

                // Update camera - direct assignment, no animations
                cam.iris = state.iris;
                cam.focus = state.focus;
                cam.exposure = state.exposure;
                cam.vignette = state.vignette;
                cam.grain = state.grain;
                cam.chromatic = state.chromatic;
                cam.lensBreathing = state.lensBreathing;
                cam.materiality = state.materiality;
                cam.sealProgress = state.sealProgress;

                // Shutter snap triggers on peak
                if (state.shutterSnap > 0 && cam.shutterSnap === 0) {
                    cam.shutterSnap = 1.0;  // Will decay via shader render loop
                }

                // Geometry opacity follows materiality
                const geometry = document.querySelector('.sacred-geometry');
                if (geometry) {
                    geometry.style.opacity = String(0.05 + state.materiality * 0.15);
                }
            },

            // ─────────────────────────────────────────
            // INITIALIZATION
            // ─────────────────────────────────────────
            init() {
                this.elements = {
                    stage: document.getElementById('ritualStage'),
                    phase: document.getElementById('ritualPhase'),
                    message: document.getElementById('ritualMessage'),
                    stamp: document.getElementById('ritualStamp'),
                    glyphs: document.getElementById('ritualGlyphs'),
                    calibration: document.getElementById('calibrationLines'),
                    cta: document.getElementById('ritualCTA'),
                    replayBtn: document.getElementById('replayRitual'),
                    heroContent: document.querySelector('.hero-content'),
                    logoSystem: document.querySelector('.logo-system')
                };

                // Bind replay button
                if (this.elements.replayBtn) {
                    this.elements.replayBtn.addEventListener('click', () => this.start());
                }

                // Pause when tab hidden
                document.addEventListener('visibilitychange', () => {
                    this.isPaused = document.hidden;
                });

                // Check accessibility before auto-start
                if (this.shouldAutoPlay()) {
                    this.scheduleStart();
                } else {
                    this.showLockedState();
                }
            },

            shouldAutoPlay() {
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    return false;
                }
                if (navigator.connection?.saveData) {
                    return false;
                }
                return true;
            },

            scheduleStart() {
                const scheduleWhenIdle = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));
                scheduleWhenIdle(() => {
                    setTimeout(() => this.start(), 100);
                }, { timeout: 500 });
            },

            // ─────────────────────────────────────────
            // THE RITUAL - SINGLE ANIMATION LOOP
            // ─────────────────────────────────────────
            start() {
                if (this.isRunning) return;

                // Reset state
                this.isRunning = true;
                this.progress = 0;
                this.isLocked = false;
                this.hasCompleted = false;
                this.stampShown = false;
                this.stampHidden = false;
                this.artifactIndex = 0;
                this.lastArtifactTime = 0;

                // Reset UI elements
                if (this.elements.cta) {
                    this.elements.cta.classList.remove('visible');
                }
                if (this.elements.stamp) {
                    this.elements.stamp.classList.remove('visible');
                }
                if (this.elements.phase) {
                    this.elements.phase.classList.remove('visible');
                }
                if (this.elements.calibration) {
                    this.elements.calibration.classList.remove('active');
                }

                // Emit start
                ProofBus.emit('ritual:state', { phase: 'start', progress: 0 });

                // Start the single animation loop
                this.startTime = Date.now();
                this.pausedTime = 0;
                this.tick();
            },

            tick() {
                if (!this.isRunning) return;

                // Handle pause
                if (this.isPaused) {
                    this.pauseStart = this.pauseStart || Date.now();
                    requestAnimationFrame(() => this.tick());
                    return;
                } else if (this.pauseStart) {
                    this.pausedTime += Date.now() - this.pauseStart;
                    this.pauseStart = null;
                }

                // Calculate progress
                const elapsed = Date.now() - this.startTime - this.pausedTime;
                this.progress = Math.min(elapsed / this.DURATION, 1);

                // Derive and apply state
                const state = this.deriveState(this.progress);
                this.applyState(state);

                // ─────────────────────────────────────────
                // PHASE-SPECIFIC EVENTS (minimal, triggered once)
                // ─────────────────────────────────────────

                // Micro-artifacts during convergence (progress 0.2-0.7)
                if (this.progress > 0.2 && this.progress < 0.7) {
                    const now = Date.now();
                    if (now - this.lastArtifactTime > 2000 && this.artifactIndex < this.microArtifacts.length) {
                        this.showMicroArtifact(this.microArtifacts[this.artifactIndex]);
                        this.artifactIndex++;
                        this.lastArtifactTime = now;
                    }
                }

                // Calibration lines during convergence
                if (this.progress > 0.25 && this.progress < 0.75) {
                    if (this.elements.calibration && !this.elements.calibration.classList.contains('active')) {
                        this.elements.calibration.classList.add('active');
                    }
                } else if (this.elements.calibration) {
                    this.elements.calibration.classList.remove('active');
                }

                // Crown assembly at midpoint
                if (this.progress > 0.5 && this.progress < 0.52 && typeof CrownSync !== 'undefined') {
                    CrownSync.animateStep(4, 11);
                }

                // Particles during build
                if (this.progress > 0.15 && this.progress < 0.2 && typeof CausalTraces !== 'undefined') {
                    CausalTraces.burst(8);
                }
                if (this.progress > 0.4 && this.progress < 0.42 && typeof CausalTraces !== 'undefined') {
                    CausalTraces.converge(12);
                }
                if (this.progress > 0.65 && this.progress < 0.67 && typeof CausalTraces !== 'undefined') {
                    CausalTraces.converge(8);
                }

                // ─────────────────────────────────────────
                // THE CAPTURE - show stamp at peak
                // ─────────────────────────────────────────
                if (this.progress >= this.CAPTURE_PEAK && !this.stampShown) {
                    this.stampShown = true;

                    // Complete crown seal
                    if (typeof CrownSync !== 'undefined') {
                        CrownSync.complete();
                    }

                    // Crystallize
                    const crystal = document.getElementById('witnessCrystal');
                    if (crystal) {
                        crystal.classList.add('locked');
                    }

                    // Show stamp
                    if (this.elements.stamp) {
                        this.elements.stamp.textContent = this.stampLine;
                        this.elements.stamp.classList.add('visible');
                    }
                }

                // Fade stamp shortly after capture
                if (this.progress >= this.CAPTURE_END + 0.08 && !this.stampHidden) {
                    this.stampHidden = true;
                    if (this.elements.stamp) {
                        this.elements.stamp.classList.remove('visible');
                    }
                }

                // ─────────────────────────────────────────
                // THE LOCK - irreversible commit
                // ─────────────────────────────────────────
                if (this.progress >= this.LOCK_POINT && !this.isLocked) {
                    this.isLocked = true;

                    // Lock sacred geometry (stop rotation)
                    const geometry = document.querySelector('.sacred-geometry');
                    if (geometry) {
                        geometry.style.animation = 'none';
                    }

                    // Hide phase indicator
                    if (this.elements.phase) {
                        this.elements.phase.classList.remove('visible');
                    }

                    ProofBus.emit('ritual:state', { phase: 'locked', progress: this.progress });
                }

                // ─────────────────────────────────────────
                // COMPLETION - stable hold state
                // ─────────────────────────────────────────
                if (this.progress >= 1) {
                    this.isRunning = false;
                    this.hasCompleted = true;

                    // Final state - seal becomes subtle watermark
                    const cam = window.RitualCamera;
                    cam.sealProgress = 0.4;
                    cam.lensBreathing = 0.1;

                    // Show CTA
                    setTimeout(() => {
                        if (this.elements.cta) {
                            this.elements.cta.classList.add('visible');
                        }
                    }, 500);

                    ProofBus.emit('ritual:complete', { completed: true });
                    return;
                }

                // Continue the loop
                requestAnimationFrame(() => this.tick());
            },

            showMicroArtifact(text) {
                if (!this.elements.phase) return;

                this.elements.phase.textContent = text;
                this.elements.phase.setAttribute('data-phase', 'converge');
                this.elements.phase.classList.add('visible');

                // Fade out after 400-600ms
                setTimeout(() => {
                    if (this.elements.phase) {
                        this.elements.phase.classList.remove('visible');
                    }
                }, 400 + Math.random() * 200);
            },

            showLockedState() {
                // For reduced motion - jump to stable end state immediately
                this.progress = 1;
                this.isLocked = true;
                this.hasCompleted = true;

                const state = this.deriveState(1);
                this.applyState(state);

                // Seal as watermark
                window.RitualCamera.sealProgress = 0.4;
                window.RitualCamera.lensBreathing = 0;

                if (typeof CrownSync !== 'undefined') {
                    CrownSync.complete();
                }

                // Lock geometry
                const geometry = document.querySelector('.sacred-geometry');
                if (geometry) {
                    geometry.style.animation = 'none';
                    geometry.style.opacity = '0.2';
                }

                // Show CTA immediately
                if (this.elements.cta) {
                    this.elements.cta.classList.add('visible');
                }
            }
        };

        // ════════════════════════════════════════════════════════════════════════════
        // CHAPTER CONTROLLER - Briefing Dossier Scroll Physics
        // ════════════════════════════════════════════════════════════════════════════
        // Keeps the teaser energy through scroll without turning into SaaS.
        // Dosed motion: one micro-reveal per chapter (300-900ms).
        // The Hold Frame persists - scroll reveals plates over the locked chamber.
        // ════════════════════════════════════════════════════════════════════════════
        const ChapterController = {
            chapters: [],
            observer: null,
            revealedChapters: new Set(),

            init() {
                // Get all chapter plates
                this.chapters = document.querySelectorAll('.chapter-plate');
                if (this.chapters.length === 0) return;

                // Set up Intersection Observer for chapter entry reveals
                const options = {
                    root: null,
                    rootMargin: '-10% 0px -20% 0px',  // Trigger when chapter is well in view
                    threshold: 0.1
                };

                this.observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !this.revealedChapters.has(entry.target.id)) {
                            this.revealChapter(entry.target);
                            this.revealedChapters.add(entry.target.id);
                        }
                    });
                }, options);

                // Observe all chapters
                this.chapters.forEach(chapter => {
                    this.observer.observe(chapter);
                });

                // Check if prefers-reduced-motion - reveal all immediately
                if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    this.revealAll();
                }
            },

            revealChapter(chapter) {
                // Add revealed class to trigger CSS transitions
                chapter.classList.add('revealed');

                // Optional: Play subtle calibration sound (commented out for now)
                // this.playCalibrationTone();
            },

            revealAll() {
                this.chapters.forEach(chapter => {
                    chapter.classList.add('revealed');
                    this.revealedChapters.add(chapter.id);
                });
            },

            // Cleanup
            destroy() {
                if (this.observer) {
                    this.observer.disconnect();
                }
            }
        };

        // ════════════════════════════════════════
        // INITIALIZATION
        // ════════════════════════════════════════
        function initProofSystem() {
            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }

            function init() {
                // Core visual systems
                WitnessCrystal.init();
                CrownSync.init();
                CausalTraces.init();
                ShaderBinding.init();

                // Reality Teaser Engine - the sovereign ritual
                RitualController.init();

                // Briefing Dossier - chapter scroll reveals
                ChapterController.init();

                console.log('%c⊢ CytherAI',
                    'color: #d4af37; font-family: monospace; font-size: 14px;');
                console.log('%c  Sovereign Neural Theorem Prover',
                    'color: #a0a4ab; font-family: monospace; font-size: 11px;');
            }
        }

        initProofSystem();

    })();
    </script>
</body>
</html>
